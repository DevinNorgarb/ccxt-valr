namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class valr { public valr(object args = null) : base(args) { } }
public partial class valr : ccxt.valr
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "watchTicker", true },
                { "watchTickers", true },
                { "watchOrderBook", true },
                { "watchOrderBookForSymbols", true },
                { "watchTrades", true },
                { "watchTradesForSymbols", true },
                { "watchBalance", true },
                { "watchOHLCV", true },
                { "watchOHLCVForSymbols", true },
                { "watchOrders", true },
                { "watchMyTrades", true },
                { "watchPositions", false },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", 60 },
                { "5m", 300 },
                { "15m", 900 },
                { "30m", 1800 },
                { "1h", 3600 },
                { "6h", 21600 },
                { "1d", 86400 },
            } },
            { "urls", new Dictionary<string, object>() {
                { "api", new Dictionary<string, object>() {
                    { "ws", new Dictionary<string, object>() {
                        { "trade", "wss://api.valr.com/ws/trade" },
                        { "account", "wss://api.valr.com/ws/account" },
                    } },
                } },
            } },
            { "options", new Dictionary<string, object>() {} },
            { "streaming", new Dictionary<string, object>() {
                { "keepAlive", 30000 },
            } },
        });
    }

    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        this.checkRequiredSymbolArgument("watchOrderBook", symbol);
        return await this.watchOrderBookForSymbols(new List<object>() {symbol}, limit, parameters);
    }

    public async override Task<object> watchOrderBookForSymbols(object symbols, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object marketIds = this.marketIds(symbols);
        if (isTrue(isTrue(isEqual(symbols, null)) || isTrue(isEqual(marketIds, null))))
        {
            throw new ArgumentsRequired ((string)add(this.id, " watchOrderBookForSymbols() requires valid symbol list")) ;
        }
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "trade");
        var client = this.authenticate(url);
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(marketIds)); postFixIncrement(ref i))
        {
            ((IList<object>)messageHashes).Add(add("AGGREGATED_ORDERBOOK_UPDATE:", getValue(marketIds, i)));
        }
        object subscriptionHashes = new List<object>(((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(subscriptionHashes)); postFixIncrement(ref i))
        {
            object subscriptionHash = getValue(subscriptionHashes, i);
            if (isTrue(isGreaterThanOrEqual(getIndexOf(subscriptionHash, "AGGREGATED_ORDERBOOK_UPDATE:"), 0)))
            {
                object subMarketId = this.safeString(((string)subscriptionHash).Split(new [] {((string)":")}, StringSplitOptions.None).ToList<object>(), 1);
                if (isTrue(isTrue(subMarketId) && !isTrue(this.inArray(subMarketId, marketIds))))
                {
                    ((IList<object>)marketIds).Add(subMarketId);
                }
            }
        }
        object message = new Dictionary<string, object>() {
            { "type", "SUBSCRIBE" },
            { "subscriptions", new List<object>() {new Dictionary<string, object>() {
    { "event", "AGGREGATED_ORDERBOOK_UPDATE" },
    { "pairs", marketIds },
}} },
        };
        object orderbook = await this.watchMultiple(url, messageHashes, message, messageHashes);
        return (orderbook as IOrderBook).limit();
    }

    public virtual void handleOrderBook(WebSocketClient client, object message)
    {
        // {
        //     "type": "AGGREGATED_ORDERBOOK_UPDATE",
        //     "currencyPairSymbol": "PYUSDUSDT",
        //     "LastChange": "2024-03-27T12:39:52.562Z",
        //     "SequenceNumber": 173347
        //     "data":
        //     {
        //         "Asks":
        //         [
        //             {
        //                 "side": "sell",
        //                 "quantity": "495.26",
        //                 "price": "0.99735",
        //                 "currencyPair": "PYUSDUSDT",
        //                 "orderCount": 1
        //             },
        //             {
        //                 "side": "sell",
        //                 "quantity": "11352.38",
        //                 "price": "0.99775",
        //                 "currencyPair": "PYUSDUSDT",
        //                 "orderCount": 1
        //             },
        //             {
        //                 "side": "sell",
        //                 "quantity": "11925.87",
        //                 "price": "0.99825",
        //                 "currencyPair": "PYUSDUSDT",
        //                 "orderCount": 1
        //             },
        //         ],
        //         "Bids":
        //         [
        //             {
        //                 "side": "buy",
        //                 "quantity": "498.38",
        //                 "price": "0.99727",
        //                 "currencyPair": "PYUSDUSDT",
        //                 "orderCount": 1
        //             },
        //             {
        //                 "side": "buy",
        //                 "quantity": "11316.78",
        //                 "price": "0.99687",
        //                 "currencyPair": "PYUSDUSDT",
        //                 "orderCount": 1
        //             },
        //             {
        //                 "side": "buy",
        //                 "quantity": "11964.06",
        //                 "price": "0.99637",
        //                 "currencyPair": "PYUSDUSDT",
        //                 "orderCount": 1
        //             },
        //         ]
        //     }
        // }
        object updateType = this.safeString(message, "type");
        object marketId = this.safeString(message, "currencyPairSymbol");
        object messageHash = add(add(updateType, ":"), marketId);
        object symbol = this.safeSymbol(marketId);
        object data = this.safeValue(message, "data");
        object nonce = this.safeInteger(data, "SequenceNumber");
        object datetime = this.safeString(data, "LastChange");
        object timestamp = this.parse8601(datetime);
        object orderbook = this.safeValue(this.orderbooks, symbol);
        if (isTrue(isEqual(orderbook, null)))
        {
            orderbook = this.countedOrderBook();
        }
        object snapshot = new Dictionary<string, object>() {
            { "asks", this.parseWsOrderBookSide(this.safeValue(data, "Asks")) },
            { "bids", this.parseWsOrderBookSide(this.safeValue(data, "Bids")) },
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", datetime },
            { "nonce", nonce },
        };
        // Using reset instead of update as csharp does not support update
        (orderbook as IOrderBook).reset(snapshot);
        ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = orderbook;
        callDynamically(client as WebSocketClient, "resolve", new object[] {orderbook, messageHash});
    }

    public virtual object parseWsOrderBookSide(object side)
    {
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(side)); postFixIncrement(ref i))
        {
            ((IList<object>)result).Add(new List<object> {this.safeNumber(getValue(side, i), "price"), this.safeNumber(getValue(side, i), "quantity"), this.safeNumber(getValue(side, i), "orderCount")});
        }
        return result;
    }

    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredSymbolArgument("watchTicker", symbol);
        object tickers = await this.watchTickers(new List<object>() {symbol}, parameters);
        return this.safeValue(tickers, symbol);
    }

    public async override Task<object> watchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object marketIds = this.marketIds(symbols);
        if (isTrue(isTrue(isEqual(symbols, null)) || isTrue(isEqual(marketIds, null))))
        {
            throw new ArgumentsRequired ((string)add(this.id, " watchTickers() requires valid symbol list")) ;
        }
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "trade");
        var client = this.authenticate(url);
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(marketIds)); postFixIncrement(ref i))
        {
            ((IList<object>)messageHashes).Add(add("MARKET_SUMMARY_UPDATE:", getValue(marketIds, i)));
        }
        object subscriptionHashes = new List<object>(((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(subscriptionHashes)); postFixIncrement(ref i))
        {
            object subscriptionHash = getValue(subscriptionHashes, i);
            if (isTrue(isGreaterThanOrEqual(getIndexOf(subscriptionHash, "MARKET_SUMMARY_UPDATE:"), 0)))
            {
                object subMarketId = this.safeString(((string)subscriptionHash).Split(new [] {((string)":")}, StringSplitOptions.None).ToList<object>(), 1);
                if (isTrue(isTrue(subMarketId) && !isTrue(this.inArray(subMarketId, marketIds))))
                {
                    ((IList<object>)marketIds).Add(subMarketId);
                }
            }
        }
        object message = new Dictionary<string, object>() {
            { "type", "SUBSCRIBE" },
            { "subscriptions", new List<object>() {new Dictionary<string, object>() {
    { "event", "MARKET_SUMMARY_UPDATE" },
    { "pairs", marketIds },
}} },
        };
        object ticker = await this.watchMultiple(url, messageHashes, message, messageHashes);
        object symbol = this.safeString(ticker, "symbol");
        object tickers = new Dictionary<string, object>() {};
        ((IDictionary<string,object>)tickers)[(string)symbol] = ticker;
        return tickers;
    }

    public virtual void handleTicker(WebSocketClient client, object message)
    {
        // {
        //     "type": "MARKET_SUMMARY_UPDATE",
        //     "currencyPairSymbol": "BTCZAR",
        //     "data":
        //     {
        //         "currencyPairSymbol": "BTCZAR",
        //         "askPrice": "1291722",
        //         "bidPrice": "1291721",
        //         "lastTradedPrice": "1291722",
        //         "previousClosePrice": "1262175",
        //         "baseVolume": "18.03385304",
        //         "quoteVolume": "22799989.56979442",
        //         "highPrice": "1293659",
        //         "lowPrice": "1243091",
        //         "created": "2024-03-24T21:49:08.217Z",
        //         "changeFromPrevious": "2.34",
        //         "markPrice": "1291638"
        //     }
        // }
        object updateType = this.safeString(message, "type");
        object marketId = this.safeString(message, "currencyPairSymbol");
        object symbol = this.symbol(marketId);
        object messageHash = add(add(updateType, ":"), marketId);
        object tickerWs = this.safeValue(message, "data");
        object ticker = this.parseTicker(tickerWs);
        ((IDictionary<string,object>)this.tickers)[(string)symbol] = ticker;
        callDynamically(client as WebSocketClient, "resolve", new object[] {ticker, messageHash});
    }

    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredSymbolArgument("watchTrades", symbol);
        return await this.watchTradesForSymbols(new List<object>() {symbol}, since, limit, parameters);
    }

    public async override Task<object> watchTradesForSymbols(object symbols, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object marketIds = this.marketIds(symbols);
        if (isTrue(isTrue(isEqual(symbols, null)) || isTrue(isEqual(marketIds, null))))
        {
            throw new ArgumentsRequired ((string)add(this.id, " watchTradesForSymbols() requires valid symbol list")) ;
        }
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "trade");
        var client = this.authenticate(url);
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(marketIds)); postFixIncrement(ref i))
        {
            ((IList<object>)messageHashes).Add(add("NEW_TRADE:", getValue(marketIds, i)));
        }
        object subscriptionHashes = new List<object>(((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(subscriptionHashes)); postFixIncrement(ref i))
        {
            object subscriptionHash = getValue(subscriptionHashes, i);
            if (isTrue(isGreaterThanOrEqual(getIndexOf(subscriptionHash, "NEW_TRADE:"), 0)))
            {
                object subMarketId = this.safeString(((string)subscriptionHash).Split(new [] {((string)":")}, StringSplitOptions.None).ToList<object>(), 1);
                if (isTrue(isTrue(subMarketId) && !isTrue(this.inArray(subMarketId, marketIds))))
                {
                    ((IList<object>)marketIds).Add(subMarketId);
                }
            }
        }
        object message = new Dictionary<string, object>() {
            { "type", "SUBSCRIBE" },
            { "subscriptions", new List<object>() {new Dictionary<string, object>() {
    { "event", "NEW_TRADE" },
    { "pairs", marketIds },
}} },
        };
        object trades = await this.watchMultiple(url, messageHashes, message, messageHashes);
        if (isTrue(this.newUpdates))
        {
            object first = this.safeValue(trades, 0);
            object tradeSymbol = this.safeString(first, "symbol");
            limit = callDynamically(trades, "getLimit", new object[] {tradeSymbol, limit});
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    public virtual void handleTrades(WebSocketClient client, object message)
    {
        // {
        //     "type": "NEW_TRADE",
        //     "currencyPairSymbol": "BTCZAR",
        //     "data":
        //     {
        //         "price": "1360468",
        //         "quantity": "0.0004402",
        //         "currencyPair": "BTCZAR",
        //         "tradedAt": "2024-03-27T12:33:19.918Z",
        //         "takerSide": "buy",
        //         "id": "31934cc3-ec36-11ee-92bb-8f9d774e71b6"
        //     }
        // }
        object updateType = this.safeString(message, "type");
        object marketId = this.safeString(message, "currencyPairSymbol");
        object messageHash = add(add(updateType, ":"), marketId);
        object symbol = this.safeSymbol(marketId);
        object data = this.safeValue(message, "data");
        object parsed = new Dictionary<string, object>() {
            { "timestamp", this.parse8601(this.safeString(data, "tradedAt")) },
            { "datetime", this.safeString(data, "tradedAt") },
            { "id", this.safeString(data, "id") },
            { "order", null },
            { "type", null },
            { "takerOrMaker", null },
            { "symbol", symbol },
            { "price", this.safeString(data, "price") },
            { "amount", this.safeString(data, "quantity") },
            { "side", this.safeString(data, "takerSide") },
            { "info", data },
            { "fee", null },
        };
        object trade = this.safeTrade(parsed);
        object stored = this.safeValue(this.trades, symbol);
        if (isTrue(isEqual(stored, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            stored = new ArrayCache(limit);
            ((IDictionary<string,object>)this.trades)[(string)symbol] = stored;
        }
        callDynamically(stored, "append", new object[] {trade});
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
    }

    public async override Task<object> watchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        this.checkRequiredSymbolArgument("watchOHLCV", symbol);
        object symbolAndTimeframe = new List<object>() {symbol, timeframe};
        object symbolsAndTimeframes = new List<object>() {symbolAndTimeframe};
        object candles = await this.watchOHLCVForSymbols(symbolsAndTimeframes, since, limit, parameters);
        object candlesSymbol = this.safeValue(candles, symbol);
        return this.safeValue(candlesSymbol, timeframe);
    }

    public async override Task<object> watchOHLCVForSymbols(object symbolsAndTimeframes, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object symbolsLength = getArrayLength(symbolsAndTimeframes);
        if (isTrue(isTrue(isEqual(symbolsLength, 0)) || !isTrue(((getValue(symbolsAndTimeframes, 0) is IList<object>) || (getValue(symbolsAndTimeframes, 0).GetType().IsGenericType && getValue(symbolsAndTimeframes, 0).GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))))
        {
            throw new ArgumentsRequired ((string)add(this.id, " watchOHLCVForSymbols() requires a an array of symbols and timeframes, like  [[\"BTC/USDT\", \"1m\"], [\"LTC/USDT\", \"5m\"]]")) ;
        }
        object marketIds = new List<object>() {};
        object symbols = new List<object>() {};
        object messageHashes = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbolsAndTimeframes)); postFixIncrement(ref i))
        {
            object symbolAndTimeframe = getValue(symbolsAndTimeframes, i);
            object timeframe = getValue(symbolAndTimeframe, 1);
            if (isTrue(isTrue((isEqual(timeframe, null))) || !isTrue((inOp(this.timeframes, timeframe)))))
            {
                throw new ArgumentsRequired ((string)add(this.id, " watchOHLCVForSymbols() requires supported timeframe option")) ;
            }
            object symbol = getValue(symbolAndTimeframe, 0);
            object marketId = this.marketId(symbol);
            this.checkRequiredSymbolArgument("watchOHLCVForSymbols", symbol);
            ((IList<object>)messageHashes).Add(add(add(add("NEW_TRADE_BUCKET_", timeframe), ":"), marketId));
            if (!isTrue(this.inArray(symbol, symbols)))
            {
                ((IList<object>)symbols).Add(symbol);
                ((IList<object>)marketIds).Add(marketId);
            }
        }
        if (isTrue(isEqual(marketIds, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " watchTradesForSymbols() requires valid symbol list")) ;
        }
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "trade");
        var client = this.authenticate(url);
        object subscriptionHashes = new List<object>(((IDictionary<string,object>)((WebSocketClient)client).subscriptions).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(subscriptionHashes)); postFixIncrement(ref i))
        {
            object subscriptionHash = getValue(subscriptionHashes, i);
            if (isTrue(isGreaterThanOrEqual(getIndexOf(subscriptionHash, "NEW_TRADE_BUCKET"), 0)))
            {
                object subMarketId = this.safeString(((string)subscriptionHash).Split(new [] {((string)":")}, StringSplitOptions.None).ToList<object>(), 1);
                if (isTrue(isTrue(subMarketId) && !isTrue(this.inArray(subMarketId, marketIds))))
                {
                    ((IList<object>)marketIds).Add(subMarketId);
                }
            }
        }
        object message = new Dictionary<string, object>() {
            { "type", "SUBSCRIBE" },
            { "subscriptions", new List<object>() {new Dictionary<string, object>() {
    { "event", "NEW_TRADE_BUCKET" },
    { "pairs", marketIds },
}} },
        };
        // call to watchMultiple only gets one of the multiple symbolsAndTimeframes returned as they all arrive
        // at the same time. The rest are stored in seperate caches.
        var symbolWstimeframeWscandlesVariable = await this.watchMultiple(url, messageHashes, message, messageHashes);
        var symbolWs = ((IList<object>) symbolWstimeframeWscandlesVariable)[0];
        var timeframeWs = ((IList<object>) symbolWstimeframeWscandlesVariable)[1];
        var candles = ((IList<object>) symbolWstimeframeWscandlesVariable)[2];
        // const symbolTimeframeCandles = {};
        if (isTrue(this.newUpdates))
        {
            // for (let i = 0; i < symbols.length; i++) {
            //     const symbolReq = symbols[i];
            //     const candleSymbol = this.safeDict (this.ohlcvs, symbolReq);
            //     if (candleSymbol !== undefined) {
            //         const candleStored = this.safeValue (candleSymbol, timeframeWs);
            //         if (candleStored !== undefined) {
            //             const limitReg = candles.getLimit (symbolWs, limit);
            //             const filtered = this.filterBySinceLimit (candles, since, limit, 0, true);
            //             symbolTimeframeCandles[symbolReq] = {};
            //             symbolTimeframeCandles[symbolReq][timeframeWs] = filtered;
            //         }
            //     }
            // }
            limit = callDynamically(candles, "getLimit", new object[] {symbolWs, limit});
        }
        object filtered = this.filterBySinceLimit(candles, since, limit, 0, true);
        return this.createOHLCVObject(symbolWs, timeframeWs, filtered);
    }

    public virtual void handleOHLCV(WebSocketClient client, object message)
    {
        // Only support timeframe of 1m
        // {
        //     type: 'NEW_TRADE_BUCKET',
        //     currencyPairSymbol: 'BTCUSDC',
        //     data: {
        //       currencyPairSymbol: 'BTCUSDC',
        //       bucketPeriodInSeconds: 60,
        //       startTime: '2024-04-05T09:03:00Z',
        //       open: '67310',
        //       high: '67310',
        //       low: '67310',
        //       close: '67310',
        //       volume: '0',
        //       quoteVolume: '0'
        //     }
        // }
        object updateType = this.safeString(message, "type");
        object marketId = this.safeString(message, "currencyPairSymbol");
        object symbol = this.safeSymbol(marketId);
        object data = this.safeValue(message, "data");
        object period = this.safeInteger(data, "bucketPeriodInSeconds");
        object timeframe = this.findTimeframe(period);
        object parsed = new List<object> {this.parse8601(this.safeString(data, "startTime")), this.safeNumber(data, "open"), this.safeNumber(data, "high"), this.safeNumber(data, "low"), this.safeNumber(data, "close"), this.safeNumber(data, "volume")};
        ((IDictionary<string,object>)this.ohlcvs)[(string)symbol] = this.safeValue(this.ohlcvs, symbol, new Dictionary<string, object>() {});
        object stored = this.safeValue(getValue(this.ohlcvs, symbol), timeframe);
        if (isTrue(isEqual(stored, null)))
        {
            object limit = this.safeInteger(this.options, "OHLCVLimit", 1000);
            stored = new ArrayCacheByTimestamp(limit);
            ((IDictionary<string,object>)getValue(this.ohlcvs, symbol))[(string)timeframe] = stored;
        }
        callDynamically(stored, "append", new object[] {parsed});
        // for multiOHLCV we need special object, as opposed to other "multi"
        // methods, because OHLCV response item does not contain symbol
        // or timeframe, thus otherwise it would be unrecognizable
        object messageHash = add(add(add(add(updateType, "_"), timeframe), ":"), marketId);
        callDynamically(client as WebSocketClient, "resolve", new object[] {new List<object>() {symbol, timeframe, stored}, messageHash});
    }

    public async override Task<object> watchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "account");
        object messageHash = "BALANCE_UPDATE";
        this.authenticate(url);
        object balances = await this.watch(url, messageHash);
        return balances;
    }

    public virtual void handleBalance(WebSocketClient client, object message)
    {
        object data = this.safeValue(message, "data");
        // {
        //     "type": "BALANCE_UPDATE",
        //     "data":
        //     {
        //         "currency":
        //         {
        //             "symbol": "R",
        //             "decimalPlaces": 2,
        //             "isActive": "True",
        //             "shortName": "ZAR",
        //             "longName": "Rand",
        //             "supportedWithdrawDecimalPlaces": 2,
        //             "collateral": "True",
        //             "collateralWeight": "0.99"
        //         },
        //         "available": "1022.05",
        //         "reserved": "10",
        //         "total": "1032.05",
        //         "updatedAt": "2024-03-25T15:38:48.580Z",
        //         "lendReserved": "0",
        //         "borrowCollateralReserved": "0",
        //         "borrowedAmount": "0",
        //         "totalInReference": "53.31359999",
        //         "totalInReferenceWeighted": "52.7804639901",
        //         "referenceCurrency": "USDC"
        //     }
        // }
        var codebalanceVariable = this.parseWsBalance(data);
        var code = ((IList<object>) codebalanceVariable)[0];
        var balance = ((IList<object>) codebalanceVariable)[1];
        if (isTrue(isEqual(this.balance, null)))
        {
            this.balance = new Dictionary<string, object>() {};
        }
        ((IDictionary<string,object>)this.balance)["info"] = this.safeValue(balance, "info");
        ((IDictionary<string,object>)this.balance)["datetime"] = this.safeString(balance, "datetime");
        ((IDictionary<string,object>)this.balance)["timestamp"] = this.safeString(balance, "timestamp");
        if (isTrue(!isEqual(code, null)))
        {
            ((IDictionary<string,object>)this.balance)[(string)code] = this.safeDict(balance, code);
            this.balance = this.safeBalance(this.balance);
        }
        object updateType = this.safeString(message, "type");
        callDynamically(client as WebSocketClient, "resolve", new object[] {balance, updateType});
    }

    public virtual object parseWsBalance(object balanceWs)
    {
        object result = new Dictionary<string, object>() {
            { "timestamp", this.parse8601(this.safeString(balanceWs, "updatedAt")) },
            { "datetime", this.safeString(balanceWs, "updatedAt") },
            { "info", balanceWs },
        };
        object currency = this.safeValue(balanceWs, "currency");
        object code = this.safeCurrencyCode(this.safeString(currency, "shortName"));
        object debt = Precise.stringAdd(this.safeString(balanceWs, "lendReserved"), this.safeString(balanceWs, "borrowReserved"));
        if (isTrue(!isEqual(code, null)))
        {
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "free", this.safeFloat(balanceWs, "available") },
                { "used", this.safeFloat(balanceWs, "reserved") },
                { "total", this.safeFloat(balanceWs, "total") },
                { "debt", debt },
            };
        }
        return new List<object>() {code, result};
    }

    public async override Task<object> watchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "account");
        object messageHash = "NEW_ACCOUNT_TRADE";
        if (isTrue(symbol))
        {
            messageHash = add(add(messageHash, ":"), symbol);
        }
        this.authenticate(url);
        object trades = await this.watch(url, messageHash);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(trades, symbol, since, limit, true);
    }

    public virtual void handleMyTrades(WebSocketClient client, object message)
    {
        // {
        //     "type": "NEW_ACCOUNT_TRADE",
        //     "currencyPairSymbol": "BTCZAR",
        //     "data": {
        //       "price": "9500",
        //       "quantity": "0.00105263",
        //       "currencyPair": "BTCZAR",
        //       "tradedAt": "2019-04-25T20:36:53.426Z",
        //       "side": "buy",
        //       "orderId":"d5a81b99-fabf-4be1-bc7c-1a00d476089d",
        //       "id":"7a2b5560-5a71-4640-9e4b-d659ed26278a"
        //     }
        //   }
        object marketId = this.safeString(message, "currencyPairSymbol");
        object symbol = this.safeSymbol(marketId);
        object tradeMessage = this.safeDict(message, "data");
        object timestamp = this.parse8601(this.safeString(tradeMessage, "tradedAt"));
        object myTrade = this.safeTrade(new Dictionary<string, object>() {
            { "info", tradeMessage },
            { "timestamp", timestamp },
            { "datetime", this.safeString(tradeMessage, "tradedAt") },
            { "id", this.safeString(tradeMessage, "id") },
            { "order", this.safeString(tradeMessage, "orderId") },
            { "symbol", symbol },
            { "side", this.safeString(tradeMessage, "side") },
            { "amount", this.safeNumber(tradeMessage, "quantity") },
            { "price", this.safeNumber(tradeMessage, "price") },
        });
        // watch All symbols
        object cachedTrades = this.myTrades;
        if (isTrue(isEqual(cachedTrades, null)))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            cachedTrades = new ArrayCacheBySymbolById(limit);
            this.myTrades = cachedTrades;
        }
        object updateType = this.safeString(message, "type");
        object messageHashSymbol = add(add(updateType, ":"), symbol);
        callDynamically(cachedTrades, "append", new object[] {myTrade});
        callDynamically(client as WebSocketClient, "resolve", new object[] {cachedTrades, updateType});
        // watch specific symbol
        callDynamically(client as WebSocketClient, "resolve", new object[] {cachedTrades, messageHashSymbol});
    }

    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "account");
        object messageHashes = new List<object>() {"OPEN_ORDERS_UPDATE", "ORDER_STATUS_UPDATE"};
        this.authenticate(url);
        if (isTrue(symbol))
        {
            for (object i = 0; isLessThan(i, getArrayLength(messageHashes)); postFixIncrement(ref i))
            {
                ((List<object>)messageHashes)[Convert.ToInt32(i)] = add(add(getValue(messageHashes, i), ":"), symbol);
            }
        }
        object orders = await this.watchMultiple(url, messageHashes);
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(orders, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(orders, symbol, since, limit);
    }

    public virtual void handleOrders(WebSocketClient client, object message)
    {
        // if (this.verbose) {
        //     this.log (this.iso8601 (this.milliseconds ()), 'handleOrders', message);
        // }
        object messageHash = this.safeString(message, "type");
        object data = this.safeValue(message, "data");
        object results = new List<object>() {};
        object messageHashesSymbol = new List<object>() {};
        object ordersMessage = new List<object>() {};
        if (isTrue(((data is IList<object>) || (data.GetType().IsGenericType && data.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            ordersMessage = this.arrayConcat(ordersMessage, data);
        } else
        {
            ((IList<object>)ordersMessage).Add(data);
        }
        for (object i = 0; isLessThan(i, getArrayLength(ordersMessage)); postFixIncrement(ref i))
        {
            object orderWs = this.parseWsOrder(getValue(ordersMessage, i));
            ((IList<object>)results).Add(orderWs);
            object symbol = this.safeString(orderWs, "symbol");
            // const orderId = this.safeString (parsed, 'id');
            if (isTrue(!isEqual(symbol, null)))
            {
                object messageHashSymbol = add(add(messageHash, ":"), symbol);
                if (!isTrue(this.inArray(messageHashesSymbol, messageHashesSymbol)))
                {
                    ((IList<object>)messageHashesSymbol).Add(messageHashSymbol);
                }
                if (isTrue(isEqual(this.orders, null)))
                {
                    object limit = this.safeInteger(this.options, "ordersLimit", 1000);
                    this.orders = new ArrayCacheBySymbolById(limit);
                }
                object cachedOrders = this.orders;
                // const orders = this.safeValue ((cachedOrders as ArrayCacheBySymbolById).hashmap, symbol, {});
                // const order = this.safeValue (orders, orderId);
                // if (order !== undefined) {
                // Use data from existing order before updating orders
                // }
                callDynamically(cachedOrders, "append", new object[] {orderWs});
            }
        }
        callDynamically(client as WebSocketClient, "resolve", new object[] {this.orders, messageHash});
        for (object i = 0; isLessThan(i, getArrayLength(messageHashesSymbol)); postFixIncrement(ref i))
        {
            callDynamically(client as WebSocketClient, "resolve", new object[] {this.orders, getValue(messageHashesSymbol, i)});
        }
    }

    public override object parseWsOrder(object order, object market = null)
    {
        // OPEN_ORDERS_UPDATE : New order added to open orders
        // [
        //     {
        //         "orderId": "38511e49-a755-4f8f-a2b1-232bae6967dc",
        //         "side": "sell",
        //         "quantity": "0.1",
        //         "price": "10000",
        //         "currencyPair": "BTCZAR"
        //         "createdAt": "2019-04-17T19:51:35.776Z",
        //         "originalQuantity": "0.1",
        //         "filledPercentage": "0.00",
        //         "type": "post-only limit",
        //         "status": "placed",
        //         "updatedAt": "2019-04-17T19:51:35.776Z",
        //         "timeInForce": "GTC",
        //         "customerOrderId": ""
        //     },
        //     {
        //         "orderId": "3f759a40-09ee-44bd-a5aa-29836bbaab1a",
        //         "side": "sell",
        //         "quantity": "0.04",
        //         "price": "10000",
        //         "currencyPair": "BTCZAR"
        //         "createdAt": "2019-04-17T19:51:35.776Z",
        //         "originalQuantity": "0.1",
        //         "filledPercentage": "60.00",
        //         "customerOrderId": "3"
        //         "type": "post-only limit",
        //         "status": "placed",
        //         "updatedAt": "2019-04-17T19:51:35.776Z",
        //         "timeInForce": "GTC",
        //     },
        // ]
        // OPEN_ORDERS_UPDATE : Open order modified
        // [
        //     {
        //         "orderId":"6eaf85b7-7e69-4e26-9664-33a8f23bfb4f",
        //         "side":"buy",
        //         "quantity":"0.0002",
        //         "price":"29300",
        //         "currencyPair":"BTCUSDC",
        //         "createdAt":"2023-10-24T13:33:43.503Z",
        //         "originalQuantity":"0.0002",
        //         "filledPercentage":"0.00",
        //         "customerOrderId":"MyLimit1234",
        //         "type":"limit",
        //         "status":"Order Modified",
        //         "updatedAt":"2023-10-24T13:36:42.660Z",
        //         "timeInForce":"GTC"
        //     },
        // ]
        // ORDER_STATUS_UPDATE : Order status has been updated
        // {
        //     "orderId": "9135e74e-bd4f-4aec-ba1f-d38897826cda",
        //     "orderStatusType": "Cancelled",
        //     "currencyPair": "BTCZAR",
        //     "originalPrice": "2100000",
        //     "remainingQuantity": "0.00002",
        //     "originalQuantity": "0.00002",
        //     "orderSide": "sell",
        //     "orderType": "post-only limit",
        //     "failedReason": "None",
        //     "orderUpdatedAt": "2024-04-01T16:14:00.963Z",
        //     "orderCreatedAt": "2024-04-01T16:01:55.985Z",
        //     "executedPrice": "0",
        //     "executedQuantity": "0",
        //     "executedFee": "0"
        // }
        // {
        //     "orderId": "bf17d427-f9e8-44ef-82c1-4ed94c5f4f7f",
        //     "orderStatusType": "Filled",
        //     "currencyPair": "BTCZAR",
        //     "originalPrice": "1335001",
        //     "remainingQuantity": "0",
        //     "originalQuantity": "0.00001",
        //     "orderSide": "sell",
        //     "orderType": "post-only limit",
        //     "failedReason": "",
        //     "orderUpdatedAt": "2024-04-01T16:14:54.716Z",
        //     "orderCreatedAt": "2024-04-01T16:13:53.400Z",
        //     "executedPrice": "1335001",
        //     "executedQuantity": "0.00001",
        //     "executedFee": "0"
        // }
        object orderStatus = this.safeString2(order, "status", "orderStatusType");
        object status = null;
        if (isTrue(isTrue(isEqual(orderStatus, "Placed")) || isTrue(isEqual(orderStatus, "Order Modified"))))
        {
            status = "open";
        } else if (isTrue(isTrue(isEqual(orderStatus, "Cancelled")) || isTrue(isEqual(orderStatus, "Failed"))))
        {
            status = "canceled";
        } else if (isTrue(isEqual(orderStatus, "Filled")))
        {
            status = "closed";
        }
        object orderTypeReceived = this.safeString(order, "type");
        object typeOrder = null;
        object postOnly = null;
        if (isTrue(!isEqual(orderTypeReceived, null)))
        {
            if (isTrue(this.inArray("limit", orderTypeReceived)))
            {
                typeOrder = "limit";
                if (isTrue(this.inArray("post-only", orderTypeReceived)))
                {
                    postOnly = true;
                } else
                {
                    postOnly = false;
                }
            }
        }
        object filledPercentage = this.safeString(order, "filledPercentage");
        object remaining = this.safeString(order, "remainingQuantity");
        object amount = this.safeString(order, "originalQuantity");
        object filled = null;
        if (isTrue(isTrue(isEqual(remaining, null)) && isTrue(!isEqual(filledPercentage, null))))
        {
            filled = Precise.stringMul(amount, filledPercentage);
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "timestamp", this.parse8601(this.safeString2(order, "createdAt", "orderCreatedAt")) },
            { "datetime", this.safeString2(order, "createdAt", "orderCreatedAt") },
            { "id", this.safeString(order, "orderId") },
            { "clientOrderId", this.safeString(order, "customerOrderId") },
            { "symbol", this.safeSymbol(this.safeString(order, "currencyPair")) },
            { "status", status },
            { "type", typeOrder },
            { "side", this.safeString2(order, "side", "orderSide") },
            { "price", this.safeString2(order, "price", "originalPrice") },
            { "amount", amount },
            { "average", this.safeString(order, "averagePrice") },
            { "filled", filled },
            { "remaining", remaining },
            { "lastUpdateTimestamp", this.parse8601(this.safeString2(order, "updatedAt", "orderUpdatedAt")) },
            { "timeInForce", this.safeString(order, "timeInForce") },
            { "postOnly", postOnly },
            { "info", order },
        });
    }

    public async virtual Task<object> watchTransactions(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object url = getValue(getValue(getValue(this.urls, "api"), "ws"), "account");
        object messageHashes = new List<object>() {"ORDER_PROCESSED", "MODIFY_ORDER_OUTCOME", "FAILED_CANCEL_ORDER"};
        this.authenticate(url);
        object result = await this.watchMultiple(url, messageHashes);
        return result;
    }

    public virtual void handleTransaction(WebSocketClient client, object message)
    {
        object messageHash = this.safeString(message, "type");
        object results = new List<object>() {};
        ((IList<object>)results).Add(message);
        callDynamically(client as WebSocketClient, "resolve", new object[] {results, messageHash});
    }

    public override object ping(WebSocketClient client)
    {
        return new Dictionary<string, object>() {
            { "type", "PING" },
        };
    }

    public virtual object handlePong(WebSocketClient client, object message)
    {
        client.lastPong = this.milliseconds();
        // {'type': 'PONG'}
        // if (this.verbose) {
        //     this.log (this.iso8601 (client.lastPong), 'handlePong', client.url, message);
        // }
        return message;
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        if (isTrue(isEqual(message, "")))
        {
            // this.log (this.iso8601 (this.milliseconds ()), 'Empty Message');
            return;
        }
        object methods = new Dictionary<string, object>() {
            { "AGGREGATED_ORDERBOOK_UPDATE", this.handleOrderBook },
            { "MARKET_SUMMARY_UPDATE", this.handleTicker },
            { "NEW_TRADE_BUCKET", this.handleOHLCV },
            { "NEW_TRADE", this.handleTrades },
            { "PONG", this.handlePong },
            { "BALANCE_UPDATE", this.handleBalance },
            { "NEW_ACCOUNT_TRADE", this.handleMyTrades },
            { "OPEN_ORDERS_UPDATE", this.handleOrders },
            { "ORDER_STATUS_UPDATE", this.handleOrders },
            { "ORDER_PROCESSED", this.handleTransaction },
            { "MODIFY_ORDER_OUTCOME", this.handleTransaction },
            { "FAILED_CANCEL_ORDER", this.handleTransaction },
        };
        object eventType = this.safeString(message, "type");
        object method = this.safeValue(methods, eventType);
        // const subscriptions = Object.values (((WebSocketClient)client).subscriptions);
        // const messageHash = Object.values (client.messageHash)
        if (isTrue(method))
        {
            // if (client.verbose) {
            //     this.log (this.iso8601 (this.milliseconds ()), 'handleMessage', 'eventType:', eventType, 'method:', method);
            // }
            DynamicInvoker.InvokeMethod(method, new object[] { client, message});
        }
    }

    public virtual object authenticate(object url)
    {
        if (isTrue(isTrue((!isEqual(this.clients, null))) && isTrue((inOp(this.clients, url)))))
        {
            return this.client(url);
        }
        this.checkRequiredCredentials();
        object timestamp = ((object)this.milliseconds()).ToString();
        object urlParts = ((string)url).Split(new [] {((string)"/")}, StringSplitOptions.None).ToList<object>();
        object partsLength = getArrayLength(urlParts);
        object path = add(add(add("/", this.safeString(urlParts, subtract(partsLength, 2))), "/"), this.safeString(urlParts, subtract(partsLength, 1)));
        object message = add(add(timestamp, "GET"), path);
        object payloadBase64 = this.stringToBase64(message);
        object signature = this.hmac(this.base64ToBinary(payloadBase64), this.base64ToBinary(this.stringToBase64(this.secret)), sha512, "hex");
        // Can't pass headers directly to this.client. Use this.options['ws'] instead.
        object defaultOptions = new Dictionary<string, object>() {
            { "ws", new Dictionary<string, object>() {
                { "options", new Dictionary<string, object>() {
                    { "headers", new Dictionary<string, object>() {} },
                } },
            } },
        };
        this.extendExchangeOptions(defaultOptions);
        object originalHeaders = getValue(getValue(getValue(this.options, "ws"), "options"), "headers");
        object headers = new Dictionary<string, object>() {
            { "X-VALR-API-KEY", this.apiKey },
            { "X-VALR-SIGNATURE", signature },
            { "X-VALR-TIMESTAMP", timestamp },
        };
        ((IDictionary<string,object>)getValue(getValue(this.options, "ws"), "options"))["headers"] = headers;
        var client = this.client(url);
        ((IDictionary<string,object>)getValue(getValue(this.options, "ws"), "options"))["headers"] = originalHeaders;
        return client;
    }
}
