namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class valr : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "valr" },
            { "name", "VALR" },
            { "countries", new List<object>() {"ZA"} },
            { "rateLimit", 1000 },
            { "version", "1" },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", null },
                { "swap", null },
                { "future", null },
                { "option", null },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "createMarketBuyOrderWithCost", true },
                { "createMarketSellOrderWithCost", true },
                { "createOrder", true },
                { "createPostOnlyOrder", true },
                { "fetchAccounts", true },
                { "fetchBalance", true },
                { "fetchClosedOrders", true },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", true },
                { "fetchDeposits", true },
                { "fetchFundingLimits", false },
                { "fetchL3OrderBook", true },
                { "fetchLedger", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrderBooks", false },
                { "fetchOrders", false },
                { "fetchPermissions", true },
                { "fetchStatus", true },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFees", true },
                { "fetchTransactions", false },
                { "fetchWithdrawals", true },
                { "transfer", false },
                { "withdraw", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", null },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://api.valr.com/v1/public" },
                    { "private", "https://api.valr.com/v1" },
                } },
                { "www", "https://www.valr.com" },
                { "doc", new List<object>() {"https://docs.valr.com/"} },
                { "fees", "https://support.valr.com/hc/en-us/articles/360015777451-What-are-VALR-s-charges" },
                { "referral", new Dictionary<string, object>() {
                    { "url", "https://www.valr.com/invite/VAE2R2GV" },
                } },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", true },
                { "secret", true },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new List<object>() {"{pair}/orderbook", "{pair}/orderbook/full", "currencies", "pairs", "ordertypes", "{pair}/ordertypes", "marketsummary", "{pair}/marketsummary", "{pair}/markprice/buckets", "{pair}/trades", "{pair}/futures/funding/history", "time", "status", "futures/info"} },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new List<object>() {"account/api-keys/current", "account/subaccounts", "account/balances", "account/balances/all", "account/transactionhistory", "account/{pair}/tradehistory", "account/fees/trade", "marketdata/{pair}/orderbook", "marketdata/{pair}/orderbook/full", "marketdata/{pair}/tradehistory", "wallet/crypto/{currency}/deposit/address", "wallet/crypto/{currency}/deposit/history", "wallet/crypto/address-book", "wallet/crypto/address-book/{currency}", "wallet/crypto/{currency}/withdraw", "wallet/crypto/{currency}/withdraw/{id}", "wallet/crypto/{currency}/withdraw/history", "wallet/fiat/{currency}/accounts/{id}", "wallet/fiat/{currency}/accounts", "wallet/fiat/{currency}/banks", "wallet/fiat/{currency}/deposit/reference", "wallet/fiat/{currency}/deposit/reference/{currency}", "wallet/fiat/{currency}/auto-buy", "wire/accounts", "simple/{pair}/order/{id}", "pay/limits", "pay/payid", "pay/history", "pay/identifier/{identifier}", "pay/transactionid/{id}", "orders/{pair}/orderid/{id}", "orders/{pair}/customerorderid/{id}", "orders/open", "orders/history", "orders/history/summary/orderid/{id}", "orders/history/summary/customerorderid/{id}", "orders/history/detail/orderid/{id}", "orders/history/detail/customerorderid/{id}", "staking/balances/{currency}", "staking/rates", "staking/rates/{currency}", "staking/rewards", "staking/history", "margin/status", "margin/account/status", "positions/open", "positions/closed/summary", "positions/closed", "positions/history", "positions/funding/history", "borrows/{currency}/history", "loans/rates"} },
                    { "post", new List<object>() {"account/subaccount", "account/subaccounts/transfer", "wallet/crypto/{currency}/withdraw", "wallet/fiat/{currency}/accounts", "wallet/fiat/{currency}/withdraw", "wire/withdrawals", "simple/{pair}/quote", "simple/{pair}/order", "pay", "orders/limit", "orders/market", "orders/stop/limit", "batch/orders", "staking/stake", "staking/un-stake"} },
                    { "put", new List<object>() {"pay/transactionid/{id}/reverse", "orders/modify", "margin/account/status"} },
                    { "delete", new List<object>() {"wallet/fiat/{currency}/accounts/{id}", "orders/order", "orders", "orders/{pair}"} },
                } },
                { "privateV2", new Dictionary<string, object>() {
                    { "get", new List<object>() {"margin/status", "healthz"} },
                    { "post", new List<object>() {"orders/market", "orders/limit", "orders/stop/limit"} },
                    { "put", new List<object>() {"orders/modify"} },
                    { "delete", new List<object>() {"orders/order"} },
                } },
            } },
            { "headers", new Dictionary<string, object>() {
                { "Content-Type", "application/json" },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "percentage", true },
                    { "maker", this.parseNumber("-0.0001") },
                    { "taker", this.parseNumber("0.003") },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "fiat", new Dictionary<string, object>() {
                    { "ZAR", "ZAR" },
                    { "USD", "USD" },
                } },
                { "tradingFeesByPairType", new Dictionary<string, object>() {
                    { "ZAR", 0.001 },
                    { "PERP", 0.0005 },
                } },
            } },
        });
    }

    public virtual void checkRequiredSymbolArgument(object methodName, object symbol)
    {
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(add(add(this.id, " "), methodName), "() requires valid symbol name")) ;
        }
        if (isTrue(!(symbol is string)))
        {
            throw new ArgumentsRequired ((string)add(add(add(this.id, " "), methodName), "() requires valid string name for symbol")) ;
        }
        object market = this.safeMarket(symbol);
        if (isTrue(isEqual(market, null)))
        {
            throw new BadSymbol ((string)add(add(add(add(this.id, " "), methodName), "() found no valid market for symbol: "), symbol)) ;
        }
    }

    public virtual void checkRequiredCurrencyCodeArgument(object methodName, object code)
    {
        if (isTrue(isEqual(code, null)))
        {
            throw new ArgumentsRequired ((string)add(add(add(this.id, " "), methodName), "() requires valid currency code name")) ;
        }
        object currency = this.safeCurrency(code);
        if (isTrue(isEqual(getValue(currency, "id"), null)))
        {
            throw new BadRequest ((string)add(add(add(add(this.id, " "), methodName), "() found no valid currency ID for currency code: "), code)) ;
        }
    }

    public virtual object isFiat(object code)
    {
        return (inOp(getValue(this.options, "fiat"), code));
    }

    public async override Task<object> fetchTime(object parameters = null)
    {
        /**
        * @method
        * @name valr#fetchTime
        * @description fetches the current integer timestamp in milliseconds from the exchange server
        * @see https://docs.valr.com/#95f84056-2ac7-4f92-a5d9-fd0d9c104f01
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int} the current integer timestamp in milliseconds from the exchange server
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetTime(parameters);
        return this.parse8601(this.safeString(response, "time"));
    }

    public async override Task<object> fetchStatus(object parameters = null)
    {
        /**
        * @method
        * @name valr#fetchStatus
        * @see https://docs.valr.com/#88ab52a2-d63b-48b2-8984-d0982baec40a
        * @description fetch status of exchange
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A [exchange status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetStatus(parameters);
        object statusReport = this.safeString(response, "status");
        object status = null;
        if (isTrue(isEqual(statusReport, "online")))
        {
            status = "ok";
        } else if (isTrue(isEqual(statusReport, "read-only")))
        {
            status = "maintenance";
        }
        return new Dictionary<string, object>() {
            { "status", status },
            { "updated", null },
            { "eta", null },
            { "url", "https://status.valr.com/" },
            { "info", response },
        };
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name valr#fetchCurrencies
        * @see https://docs.valr.com/#88ab52a2-d63b-48b2-8984-d0982baec40a
        * @description fetches all available currencies on an exchange
        * @param {{}} [params={}] extra parameters specific to the exchange API endpoint
        * @returns {object} an associative dictionary of [Currency Structure]{@link https://docs.ccxt.com/#/?id=currency-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object currencies = await this.publicGetCurrencies(parameters);
        // [
        //     {
        //       "symbol": "R",
        //       "isActive": true,
        //       "shortName": "ZAR",
        //       "longName": "Rand",
        //       "decimalPlaces": "2",
        //       "withdrawalDecimalPlaces": "2",
        //       "collateral": true,
        //       "collateralWeight": "1"
        //     },
        //     {
        //       "symbol": "BTC",
        //       "isActive": true,
        //       "shortName": "BTC",
        //       "longName": "Bitcoin",
        //       "decimalPlaces": "8",
        //       "withdrawalDecimalPlaces": "8",
        //       "collateral": true,
        //       "collateralWeight": "0.95",
        //       "defaultNetworkType": "Bitcoin",
        //       "supportedNetworks": [
        //         {
        //           "networkType": "Bitcoin",
        //           "networkLongName": "Bitcoin"
        //         }
        //       ]
        //     },
        //     {
        //       "symbol": "ETH",
        //       "isActive": true,
        //       "shortName": "ETH",
        //       "longName": "Ethereum",
        //       "decimalPlaces": "18",
        //       "withdrawalDecimalPlaces": "8",
        //       "collateral": true,
        //       "collateralWeight": "0.95",
        //       "defaultNetworkType": "Ethereum",
        //       "supportedNetworks": [
        //         {
        //           "networkType": "Ethereum",
        //           "networkLongName": "Ethereum"
        //         }
        //       ]
        //     },
        //     ...
        // ]
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(currencies)); postFixIncrement(ref i))
        {
            object currency = getValue(currencies, i);
            object code = this.safeCurrencyCode(this.safeString(currency, "shortName"));
            object precision = this.safeInteger(currency, "decimalPlaces");
            // Siacoin reports precision of 24 which does not pass build test
            if (isTrue(isTrue((!isEqual(precision, null))) && isTrue((isGreaterThan(precision, 18)))))
            {
                precision = 18;
            }
            ((IDictionary<string,object>)result)[(string)code] = this.safeCurrencyStructure(new Dictionary<string, object>() {
                { "id", this.safeString(currency, "shortName") },
                { "code", code },
                { "info", currency },
                { "name", this.safeString(currency, "longName") },
                { "active", this.safeString(currency, "isActive") },
                { "precision", precision },
                { "withdraw", ((bool) isTrue((inOp(currency, "supportedNetworks")))) ? true : false },
                { "deposit", ((bool) isTrue((inOp(currency, "supportedNetworks")))) ? true : false },
            });
        }
        return result;
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name valr#fetchMarkets
        * @description retrieves data on all markets for valr
        * @see https://docs.valr.com/#cfa57d7e-2106-4066-bc27-c10210b6aa82
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a list of [Market Structure]{@link https://docs.ccxt.com/#/?id=market-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object markets = await this.publicGetPairs(parameters);
        // [
        //     {'symbol': 'ENJUSDC',
        //     'baseCurrency': 'ENJ',
        //     'quoteCurrency': 'USDC',
        //     'shortName': 'ENJ/USDC',
        //     'active': True,
        //     'minBaseAmount': '3.5',
        //     'maxBaseAmount': '3586.3',
        //     'minQuoteAmount': '2',
        //     'maxQuoteAmount': '5000',
        //     'tickSize': '0.01',
        //     'baseDecimalPlaces': '2',
        //     'marginTradingAllowed': False,
        //     'currencyPairType': 'SPOT'},
        //    {'symbol': 'USDTZARPERP',
        //     'baseCurrency': 'USDT',
        //     'quoteCurrency': 'ZAR',
        //     'shortName': 'USDT/ZARPERP',
        //     'active': True,
        //     'minBaseAmount': '1',
        //     'maxBaseAmount': '250000',
        //     'minQuoteAmount': '15',
        //     'maxQuoteAmount': '5000000',
        //     'tickSize': '0.01',
        //     'baseDecimalPlaces': '3',
        //     'marginTradingAllowed': False,
        //     'currencyPairType': 'FUTURE'
        // },
        // ]
        return this.parseMarkets(markets);
    }

    public override object parseMarket(object market)
    {
        object bs = this.safeCurrencyCode(this.safeString(market, "baseCurrency"));
        object quote = this.safeCurrencyCode(this.safeString(market, "quoteCurrency"));
        object currencyPairType = this.safeString(market, "currencyPairType");
        object marketType = null;
        object spot = null;
        object swap = null;
        object symbol = add(add(bs, "/"), quote);
        // required for future contracts
        object contract = false;
        object linear = null;
        object contractSize = null;
        object settle = null;
        object settleId = null;
        object taker = this.safeNumber(getValue(this.options, "tradingFeesByPairType"), quote, getValue(getValue(this.fees, "trading"), "taker"));
        if (isTrue(isEqual(currencyPairType, "SPOT")))
        {
            marketType = "spot";
            spot = true;
        } else if (isTrue(isEqual(currencyPairType, "FUTURE")))
        {
            taker = this.safeNumber(getValue(this.options, "tradingFeesByPairType"), "PERP", getValue(getValue(this.fees, "trading"), "taker"));
            marketType = "swap";
            spot = false;
            swap = true;
            symbol = add(add(symbol, ":"), quote);
            contract = true;
            // Guess value
            contractSize = this.parseNumber("1");
            // According to docs: https://support.valr.com/hc/en-us/articles/11078306427420-Perpetual-Futures-Trading-Guide
            linear = true;
            settle = bs;
            settleId = this.safeString(market, "baseCurrency");
            symbol = add(add(add(add(bs, "/"), quote), ":"), settle);
        }
        return this.safeMarketStructure(new Dictionary<string, object>() {
            { "id", this.safeString(market, "symbol") },
            { "symbol", symbol },
            { "base", bs },
            { "quote", quote },
            { "baseId", this.safeString(market, "baseCurrency") },
            { "quoteId", this.safeString(market, "quoteCurrency") },
            { "active", this.safeBool(market, "active") },
            { "type", marketType },
            { "spot", spot },
            { "margin", this.safeBool(market, "marginTradingAllowed") },
            { "future", false },
            { "swap", swap },
            { "option", false },
            { "contract", contract },
            { "percentage", true },
            { "tierBased", false },
            { "linear", linear },
            { "contractSize", contractSize },
            { "settle", settle },
            { "settleId", settleId },
            { "taker", taker },
            { "maker", this.parseNumber(getValue(getValue(this.fees, "trading"), "maker")) },
            { "precision", new Dictionary<string, object>() {
                { "price", this.precisionFromString(this.safeString(market, "tickSize")) },
                { "amount", this.safeInteger(market, "baseDecimalPlaces") },
            } },
            { "limits", new Dictionary<string, object>() {
                { "amount", new Dictionary<string, object>() {
                    { "min", this.safeFloat(market, "minBaseAmount") },
                    { "max", this.safeFloat(market, "maxBaseAmount") },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", this.safeFloat(market, "minQuoteAmount") },
                    { "max", this.safeFloat(market, "maxQuoteAmount") },
                } },
            } },
            { "info", market },
        });
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name valr#fetchTickers
        * @see https://docs.valr.com/#cd1f0448-3da3-44cf-b00d-91edd74e7e19
        * @description fetch market statistics for the multiple markets on the exchange
        * @param {string} [symbol] unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a assiative array of [Ticker Structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.publicGetMarketsummary(parameters);
        // [
        //     {
        //       "currencyPair": "BTCZAR",
        //       "askPrice": "520000",
        //       "bidPrice": "400000",
        //       "lastTradedPrice": "400000",
        //       "previousClosePrice": "400000",
        //       "baseVolume": "0",
        //       "highPrice": "400000",
        //       "lowPrice": "0",
        //       "created": "2022-06-12T18:06:05.001Z",
        //       "changeFromPrevious": "0",
        //       "markPrice": "400000"
        //     },
        //     {
        //       "currencyPair": "ETHZAR",
        //       "askPrice": "32158",
        //       "bidPrice": "30899",
        //       "lastTradedPrice": "30899",
        //       "previousClosePrice": "30899",
        //       "baseVolume": "0",
        //       "highPrice": "30899",
        //       "lowPrice": "0",
        //       "created": "2022-06-12T18:06:05.001Z",
        //       "changeFromPrevious": "0",
        //       "markPrice": "30899"
        //     },
        //     ...
        // ]
        return this.parseTickers(response, symbols, parameters);
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name valr#fetchTicker
        * @see https://docs.valr.com/#89b446bb-60a6-42ff-aa09-29e4918a9eb0
        * @description fetch market statistics for a market on the exchange
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [Ticker Structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        this.checkRequiredSymbolArgument(add(this.id, " fetchTicker"), symbol);
        object marketId = this.marketId(symbol);
        object request = new Dictionary<string, object>() {
            { "pair", marketId },
        };
        object response = await this.publicGetPairMarketsummary(this.extend(request, parameters));
        return this.parseTicker(response);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        object timestamp = this.parse8601(this.safeString(ticker, "created"));
        object result = new Dictionary<string, object>() {
            { "symbol", this.safeSymbol(this.safeString2(ticker, "currencyPair", "currencyPairSymbol")) },
            { "info", ticker },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(ticker, "highPrice") },
            { "low", this.safeString(ticker, "lowPrice") },
            { "bid", this.safeString(ticker, "bidPrice") },
            { "ask", this.safeString(ticker, "askPrice") },
            { "close", this.safeString(ticker, "") },
            { "last", this.safeString(ticker, "lastTradedPrice") },
            { "open", this.safeString(ticker, "previousClosePrice") },
            { "previousClose", this.safeString(ticker, "previousClosePrice") },
            { "average", this.safeString(ticker, "markPrice") },
            { "change", null },
            { "percentage", this.safeString(ticker, "changeFromPrevious") },
            { "baseVolume", this.safeString(ticker, "baseVolume") },
            { "quoteVolume", this.safeString(ticker, "quoteVolume") },
        };
        return this.safeTicker(result);
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name valr#fetchOrderBook
        * @see https://docs.valr.com/#89b446bb-60a6-42ff-aa09-29e4918a9eb0
        * @description fetches upto a maximum of the top 40 bids and asks in the order book
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {Int} [limit] the maximum number of order book structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [Order Book Structure]{@link https://docs.ccxt.com/#/?id=order-book-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = null;
        this.checkRequiredSymbolArgument("fetchOrderBook", symbol);
        ((IDictionary<string,object>)parameters)["pair"] = this.marketId(symbol);
        if (isTrue(this.checkRequiredCredentials(false)))
        {
            response = await this.privateGetMarketdataPairOrderbook(parameters);
        } else
        {
            response = await this.publicGetPairOrderbook(parameters);
        }
        object lastDateChange = this.safeString(response, "LastChange");
        object timestamp = this.parse8601(lastDateChange);
        return this.parseOrderBook(response, symbol, timestamp, "Bids", "Asks", "price", "quantity", "orderCount");
    }

    public async override Task<object> fetchL3OrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name valr#fetchL3OrderBook
        * @see https://docs.valr.com/#c2acf6b9-dbba-4e6a-9075-a7907360812d
        * @description fetches all bids and asks in the order book
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {Int} [limit] the maximum number of order book structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [Order Book Structure]{@link https://docs.ccxt.com/#/?id=order-book-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = null;
        this.checkRequiredSymbolArgument("fetchOrderBook", symbol);
        ((IDictionary<string,object>)parameters)["pair"] = this.marketId(symbol);
        if (isTrue(this.checkRequiredCredentials(false)))
        {
            response = await this.privateGetMarketdataPairOrderbookFull(parameters);
        } else
        {
            response = await this.publicGetPairOrderbookFull(parameters);
        }
        object lastDateChange = this.safeString(response, "LastChange");
        object timestamp = this.parse8601(lastDateChange);
        return this.parseOrderBook(response, symbol, timestamp, "Bids", "Asks", "price", "quantity", "id");
    }

    public async override Task<object> fetchPermissions(object parameters = null)
    {
        /**
        * @method
        * @name valr#fetchPermissions
        * @see https://docs.valr.com/#af083ac6-0514-4979-9bab-f599ea1bed4f
        * @description returns the current API Key's information and permissions.
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns an associative array with API enable permissions
        */
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        object response = this.privateGetAccountApiKeysCurrent(parameters);
        object permissions = this.safeValue(response, "permissions");
        return new Dictionary<string, object>() {
            { "info", response },
            { "created", this.parse8601(this.safeString(response, "addedAt")) },
            { "viewaccess", this.inArray("View access", permissions) },
            { "trade", this.inArray("Trade", permissions) },
            { "cryptwithdraws", this.inArray("Withdraw", permissions) },
            { "fiatwithdraws", this.inArray("Link bank account", permissions) },
            { "transfers", this.inArray("Internal Transfer", permissions) },
        };
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name valr#fetchBalance
        * @see https://docs.valr.com/#60455ec7-ecdc-42ad-9a57-64941299da52
        * @description fetches the the balances in all currencies on the user account.
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a associative array of [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetAccountBalances(parameters);
        // [
        //     {
        //       "currency": "USDT",
        //       "available": "44822.97549155",
        //       "reserved": "99.99925",
        //       "total": "145612.43129945",
        //       "updatedAt": "2023-04-25T09:00:04.406Z",
        //       "lendReserved": "100000",
        //       "borrowReserved": "689.4565579",
        //       "borrowedAmount": "0",
        //       "totalInReference": "7828.62533868",
        //       "totalInReferenceWeighted": "7828.62533868",
        //       "referenceCurrency": "USDC"
        //     },
        //     {
        //       "currency": "BTC",
        //       "available": "0",
        //       "reserved": "0",
        //       "total": "-0.00101056",
        //       "updatedAt": "2023-04-25T09:00:00.103Z",
        //       "lendReserved": "0",
        //       "borrowReserved": "0",
        //       "borrowedAmount": "0.00101056",
        //       "totalInReference": "-28.29568",
        //       "totalInReferenceWeighted": "-27.588288",
        //       "referenceCurrency": "USDC"
        //     }
        // ]
        return this.parseBalance(response);
    }

    public override object parseBalance(object balances)
    {
        object result = new Dictionary<string, object>() {
            { "timestamp", null },
            { "datetime", null },
            { "info", balances },
        };
        for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
        {
            object balance = getValue(balances, i);
            object code = this.safeCurrencyCode(this.safeString(balance, "currency"));
            object debt = Precise.stringAdd(this.safeString(balance, "lendReserved"), this.safeString(balance, "borrowReserved"));
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "free", this.safeFloat(balance, "available") },
                { "used", this.safeFloat(balance, "reserved") },
                { "total", this.safeFloat(balance, "total") },
                { "debt", debt },
            };
        }
        return this.safeBalance(result);
    }

    public async override Task<object> fetchAccounts(object parameters = null)
    {
        /**
        * @method
        * @name valr#fetchAccounts
        * @see https://docs.valr.com/#9443d7ce-c1c5-4597-b43e-d8fc2e7b49a7
        * @description fetch all the accounts associated with a profile
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/#/?id=account-structure} indexed by the account type
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.privateGetAccountSubaccounts(parameters);
        return this.parseAccounts(response, parameters);
    }

    public override object parseAccount(object account)
    {
        object accountType = null;
        if (isTrue(isEqual(this.safeString(account, "label"), "Primary")))
        {
            accountType = "main";
        } else
        {
            accountType = "subaccount";
        }
        // Todo: Use account structure
        return new Dictionary<string, object>() {
            { "id", this.safeString(account, "id") },
            { "type", accountType },
            { "name", this.safeString(account, "label") },
            { "code", null },
            { "info", account },
        };
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name valr#fetchOrder
        * @see https://docs.valr.com/#8d9252e1-ee27-495e-86ed-57458bdafd19
        * @description fetches information on an order made by the user
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        this.checkRequiredSymbolArgument("fetchOrder", symbol);
        object marketId = this.marketId(symbol);
        object request = new Dictionary<string, object>() {
            { "id", id },
            { "pair", marketId },
        };
        object response = await this.privateGetOrdersPairOrderidId(this.extend(request, parameters));
        // {
        //     "orderId": "00fa7cb4-ea7c-4b8e-beed-dc63e226a6a2",
        //     "orderStatusType": "Placed",
        //     "currencyPair": "BTCZAR",
        //     "originalPrice": "100000",
        //     "remainingQuantity": "0.02",
        //     "originalQuantity": "0.02",
        //     "orderSide": "buy",
        //     "orderType": "post-only limit",
        //     "failedReason": "",
        //     "orderUpdatedAt": "2024-03-12T09:42:37.766Z",
        //     "orderCreatedAt": "2024-03-12T09:42:37.766Z",
        //     "timeInForce": "GTC"
        // }
        return this.parseOrder(response);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name valr#fetchOpenOrders
        * @description fetches information on all order made by the user
        * @see https://docs.valr.com/#910bc498-b88d-48e8-b392-6cc94b8cb66d
        * @param {string} [symbol] unified symbol of the market the order was made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a list of [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetOrdersOpen(parameters);
        // [{'orderId': 'aa6dce9a-6acb-477f-9da8-223127e6b32d',
        // 'side': 'buy',
        // 'remainingQuantity': '0.02',
        // 'price': '100000',
        // 'currencyPair': 'BTCZAR',
        // 'createdAt': '2024-03-12T07:14:17.275Z',
        // 'originalQuantity': '0.02',
        // 'filledPercentage': '0.00',
        // 'updatedAt': '2024-03-12T07:14:17.275Z',
        // 'status': 'Placed',
        // 'type': 'post-only limit',
        // 'timeInForce': 'GTC'}]
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.safeValue(this.markets, symbol);
        }
        return this.parseOrders(response, market, since, limit, parameters);
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name valr#fetchOpenOrders
        * @description fetches information on all closed order made by the user
        * @see https://docs.valr.com/#0d7cc0ff-b8ca-4e1f-980e-36d07672e53d
        * @param {string} [symbol] unified symbol of the market the order was made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a list of [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetOrdersHistory(parameters);
        // [{'orderId': 'aa6dce9a-6acb-477f-9da8-223127e6b32d',
        //   'orderStatusType': 'Cancelled',
        //   'currencyPair': 'BTCZAR',
        //   'averagePrice': '0',
        //   'originalPrice': '100000',
        //   'remainingQuantity': '0.02',
        //   'originalQuantity': '0.02',
        //   'total': '0',
        //   'totalFee': '0',
        //   'feeCurrency': 'BTC',
        //   'orderSide': 'buy',
        //   'orderType': 'post-only limit',
        //   'failedReason': '',
        //   'orderUpdatedAt': '2024-03-12T07:16:14.205Z',
        //   'orderCreatedAt': '2024-03-12T07:14:17.275Z',
        //   'timeInForce': 'GTC'}]
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.safeValue(this.markets, symbol);
        }
        return this.parseOrders(response, market, since, limit, parameters);
    }

    public override object parseOrder(object order, object market = null)
    {
        object orderStatus = this.safeString(order, "status");
        object status = null;
        if (isTrue(isTrue(isEqual(orderStatus, "Placed")) || isTrue(isEqual(orderStatus, "Active"))))
        {
            status = "open";
        } else if (isTrue(isEqual(orderStatus, "Failed")))
        {
            status = "canceled";
        } else if (isTrue(isEqual(orderStatus, "Filled")))
        {
            status = "closed";
        }
        object orderType = this.safeString2(order, "type", "orderType");
        object type = null;
        if (isTrue(!isEqual(orderType, null)))
        {
            if (isTrue(isEqual(orderType, "market")))
            {
                type = "market";
            } else if (isTrue(getIndexOf(orderType, "limit")))
            {
                type = "limit";
            }
        }
        object datetime = this.safeString2(order, "createdAt", "orderCreatedAt");
        object updateDatetime = this.safeString2(order, "updatedAt", "orderUpdatedAt");
        object result = new Dictionary<string, object>() {
            { "id", this.safeString(order, "orderId") },
            { "clientOrderId", this.safeString(order, "customerOrderId") },
            { "timestamp", this.parse8601(datetime) },
            { "datetime", datetime },
            { "symbol", this.safeSymbol(this.safeString(order, "currencyPair")) },
            { "type", type },
            { "side", this.safeString(order, "side") },
            { "lastTradeTimestamp", null },
            { "lastUpdateTimestamp", this.parse8601(updateDatetime) },
            { "price", this.safeString(order, "price") },
            { "amount", this.safeString(order, "originalQuantity") },
            { "cost", null },
            { "average", this.safeString(order, "averagePrice") },
            { "filled", null },
            { "remaining", this.safeString(order, "remainingQuantity") },
            { "timeInForce", this.safeString(order, "timeInForce") },
            { "postOnly", null },
            { "trades", null },
            { "reduceOnly", this.safeValue(order, "reduceOnly") },
            { "triggerPrice", null },
            { "takeProfitPrice", null },
            { "stopLossPrice", null },
            { "status", status },
            { "fee", null },
            { "info", order },
        };
        return this.safeOrder(result, market);
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name valr#createOrder
        * @see https://docs.valr.com/#5beb7328-24ca-4d8a-84f2-6029725ad923
        * @description Create a trade order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency. If included in market order, use quote amount
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {object} [params.postOnly] if true will place a limit order and fail if matched immidiately
        * @param {object} [params.customerOrderId] an optional field which can be specified by clients to track this order using their own internal order management systems
        * @param {object} [params.allowMargin] Set to true for a margin / leverage trade
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure} with only the id and symbol added
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = null;
        this.checkRequiredSymbolArgument("createOrder", symbol);
        object marketId = this.marketId(symbol);
        if (isTrue(isTrue(!isEqual(side, "buy")) && isTrue(!isEqual(side, "sell"))))
        {
            throw new InvalidOrder ((string)add(this.id, " createOrder() - \"side\" must be either \"buy\" or \"sell\".")) ;
        }
        object body = new Dictionary<string, object>() {
            { "side", ((string)side).ToUpper() },
            { "pair", marketId },
        };
        // Optional parameters
        if (isTrue(this.safeString(parameters, "customerOrderId")))
        {
            ((IDictionary<string,object>)body)["customerOrderId"] = this.safeString(parameters, "customerOrderId");
        }
        if (isTrue(this.safeString(parameters, "allowMargin")))
        {
            ((IDictionary<string,object>)body)["allowMargin"] = this.safeString(parameters, "allowMargin");
        }
        this.omit(parameters, new List<object>() {"allowMargin", "customerOrderId"});
        if (isTrue(isEqual(type, "market")))
        {
            if (isTrue(price))
            {
                ((IDictionary<string,object>)body)["quoteAmount"] = amount;
            } else
            {
                ((IDictionary<string,object>)body)["baseAmount"] = amount;
            }
            this.omit(parameters, new List<object>() {"baseAmount", "quoteAmount"});
            response = await this.privatePostOrdersMarket(this.extend(body, parameters));
        } else if (isTrue(isEqual(type, "limit")))
        {
            ((IDictionary<string,object>)body)["price"] = this.numberToString(price);
            ((IDictionary<string,object>)body)["quantity"] = this.numberToString(amount);
            if (isTrue(this.safeString(parameters, "postOnly")))
            {
                ((IDictionary<string,object>)body)["postOnly"] = this.safeBool(parameters, "postOnly");
                this.omit(parameters, "postOnly");
            }
            response = await this.privatePostOrdersLimit(this.extend(body, parameters));
        } else
        {
            throw new InvalidOrder ((string)add(this.id, " createOrder() - \"type\" must be either \"market\" or \"limit\" to create an order.")) ;
        }
        return this.parseOrder(new Dictionary<string, object>() {
            { "orderId", this.safeString(response, "id") },
            { "currencyPair", marketId },
        });
    }

    public async override Task<object> createOrders(object orders, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        throw new NotSupported ((string)add(this.id, " createOrders() is not supported yet")) ;
    }

    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        await this.cancelOrder(id, symbol);
        return await this.createOrder(symbol, type, side, amount, price, parameters);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name valr#cancelOrder
        * @see https://docs.valr.com/#3d9ba169-7222-4c0f-ab08-87c22162c0c4
        * @description cancels an open order
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure} with only the id and symbol added
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        this.checkRequiredSymbolArgument("cancelOrder", symbol);
        object marketId = this.marketId(symbol);
        object orderFormat = new Dictionary<string, object>() {
            { "orderId", id },
            { "pair", marketId },
        };
        await this.privateDeleteOrdersOrder(this.extend(orderFormat, parameters));
        return this.parseOrder(new Dictionary<string, object>() {
            { "id", id },
            { "currencyPair", marketId },
        });
    }

    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name valr#cancelAllOrders
        * @see https://docs.valr.com/#90822956-7e25-48a8-bd14-a83fb8766b46
        * @description cancels all an open order or all open orders on a specific market
        * @param {string} [symbol] unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an list of [order structure]{@link https://docs.ccxt.com/#/?id=order-structure} with only the id and option symbol added
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = null;
        if (isTrue(isEqual(symbol, null)))
        {
            response = this.privateDeleteOrders(parameters);
        } else
        {
            this.checkRequiredSymbolArgument("cancelAllOrders", symbol);
            object marketId = this.marketId(symbol);
            object body = new Dictionary<string, object>() {
                { "pair", marketId },
            };
            response = await this.privateDeleteOrdersPair(this.extend(body, parameters));
            for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
            {
                ((IDictionary<string,object>)getValue(response, i))["currencyPair"] = marketId;
            }
        }
        return this.parseOrders(response);
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name valr#fetchTrades
        * @see https://docs.valr.com/#68ecbf66-c8ab-4460-a1f3-5b245b15877e
        * @see https://docs.valr.com/#8e9429c0-f43b-4483-a2be-d03cd1bbb230
        * @description get the list of most recent trades for a particular symbol. If API keys present, use private API call for improved rate limits
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = null;
        this.checkRequiredSymbolArgument("fetchTrades", symbol);
        ((IDictionary<string,object>)parameters)["pair"] = this.marketId(symbol);
        if (isTrue(this.checkRequiredCredentials(false)))
        {
            response = await this.privateGetMarketdataPairTradehistory(parameters);
        } else
        {
            response = await this.publicGetPairTrades(parameters);
        }
        return this.parseTrades(response, null, since, limit, parameters);
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name valr#fetchTrades
        * @see https://docs.valr.com/#68ecbf66-c8ab-4460-a1f3-5b245b15877e
        * @see https://docs.valr.com/#8e9429c0-f43b-4483-a2be-d03cd1bbb230
        * @description get the list of most recent trades for a particular symbol for the profile.
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        this.checkRequiredSymbolArgument("fetchMyTrades", symbol);
        ((IDictionary<string,object>)parameters)["pair"] = this.marketId(symbol);
        object response = await this.privateGetAccountPairTradehistory(parameters);
        // [
        //     {
        //       "price": "29001",
        //       "quantity": "0.00137926",
        //       "currencyPair": "BTCUSDC",
        //       "tradedAt": "2024-02-07T06:00:30.180Z",
        //       "side": "buy",
        //       "sequenceId": 1204667988813283300,
        //       "id": "32ad194e-c57e-11ee-9935-593da58a6690",
        //       "orderId": "3fda280f-e87e-44c8-babf-852da844e514",
        //       "fee": "0.000000413778",
        //       "feeCurrency": "BTC"
        //     },
        //     {'price': '19.3017',
        //     'quantity': '1',
        //     'currencyPair': 'USDCZAR',
        //     'tradedAt': '2024-02-27T14:46:44.852Z',
        //     'side': 'sell',
        //     'sequenceId': '1212048179894161409',
        //     'id': '06e88b34-d57f-11ee-92bb-d59de6d96a53',
        //     'orderId': '5ae9af1e-eb05-427e-af4f-50bcbd9dc8f1',
        //     'makerReward': '0.0001',
        //     'makerRewardCurrency': 'USDC'}
        // ]
        return this.parseTrades(response, null, since, limit, parameters);
    }

    public override object parseTrade(object trade, object market = null)
    {
        object symbol = this.safeSymbol(this.safeString(trade, "currencyPair"));
        object timestamp = this.parse8601(this.safeString(trade, "tradedAt"));
        object takerOrMaker = null;
        object feeCost = this.safeNumber2(trade, "fee", "makerReward");
        // let tradeType = undefined;
        if (isTrue(inOp(trade, "makerReward")))
        {
            takerOrMaker = "maker";
            feeCost = ((bool) isTrue((feeCost))) ? prefixUnaryNeg(ref feeCost) : feeCost;
        } else
        {
            takerOrMaker = "taker";
        }
        object fee = new Dictionary<string, object>() {
            { "currency", this.safeString2(trade, "feeCurrency", "makerRewardCurrency") },
            { "cost", feeCost },
            { "rate", null },
        };
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.safeString(trade, "tradedAt") },
            { "id", this.safeString(trade, "id") },
            { "order", this.safeString(trade, "orderId") },
            { "symbol", symbol },
            { "type", ((bool) isTrue((isEqual(takerOrMaker, "taker")))) ? "market" : "limit" },
            { "side", this.safeString2(trade, "side", "takerSide") },
            { "amount", this.safeNumber(trade, "quantity") },
            { "price", this.safeNumber(trade, "price") },
            { "cost", this.safeNumber(trade, "quoteVolume") },
            { "takerOrMaker", takerOrMaker },
            { "fee", fee },
        });
    }

    public async override Task<object> fetchTradingFees(object parameters = null)
    {
        /**
        * @method
        * @name valr#fetchTradingFees
        * @see https://docs.valr.com/#00502bc7-bf1e-40d5-b284-25fa719f0229
        * @description fetch the trading fees for multiple markets
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetAccountFeesTrade(parameters);
        if (!isTrue(((response is IList<object>) || (response.GetType().IsGenericType && response.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            throw new NullResponse ((string)add(add(this.id, " "), "fetchTradingFees() received incorrect response")) ;
        }
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object tradeFee = getValue(response, i);
            object symbol = this.safeSymbol(this.safeString(tradeFee, "currencyPair"));
            if (isTrue(isTrue((inOp(tradeFee, "makerPercentage"))) && isTrue((inOp(tradeFee, "takerPercentage")))))
            {
                object makerStr = this.safeString(tradeFee, "makerPercentage");
                object takerStr = this.safeString(tradeFee, "takerPercentage");
                makerStr = ((bool) isTrue((makerStr))) ? Precise.stringDiv(makerStr, "100") : null;
                takerStr = ((bool) isTrue((takerStr))) ? Precise.stringDiv(takerStr, "100") : null;
                ((IDictionary<string,object>)result)[(string)symbol] = new Dictionary<string, object>() {
                    { "maker", this.parseNumber(makerStr) },
                    { "taker", this.parseNumber(takerStr) },
                    { "info", tradeFee },
                    { "symbol", symbol },
                    { "percentage", true },
                    { "tierBased", false },
                };
            } else
            {
                continue;
            }
        }
        return result;
    }

    public async virtual Task loadTradingFees(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object tradingFees = await this.fetchTradingFees(parameters);
        object tradingFeesList = this.toArray(tradingFees);
        for (object i = 0; isLessThan(i, getArrayLength(tradingFeesList)); postFixIncrement(ref i))
        {
            object tradeFee = getValue(tradingFeesList, i);
            object symbol = getValue(tradeFee, "symbol");
            if (isTrue(this.inArray(symbol, this.markets)))
            {
                ((IDictionary<string,object>)getValue(this.markets, symbol))["taker"] = getValue(tradeFee, "taker");
                ((IDictionary<string,object>)getValue(this.markets, symbol))["maker"] = getValue(tradeFee, "maker");
            }
        }
    }

    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name valr#fetchDepositAddress
        * @see https://docs.valr.com/#b10ea5dd-00cb-4c33-bb28-53104a8f1b7b
        * @see https://docs.valr.com/#619d83fa-f562-4ed3-a573-81afbafd2f1c
        * @description fetch the deposit address for a currency associated with this account
        * @param {string} code unified currency code
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        this.checkRequiredCurrencyCodeArgument("fetchDepositAddress", code);
        object response = null;
        object currency = this.safeCurrency(code);
        object currencyId = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        if (isTrue(this.isFiat(code)))
        {
            response = await this.privateGetWalletFiatCurrencyDepositReference(this.extend(currencyId, parameters));
        } else
        {
            response = await this.privateGetWalletCryptoCurrencyDepositAddress(this.extend(currencyId, parameters));
        }
        return this.parseDepositAddress(response, currency);
    }

    public override object parseDepositAddress(object depositAddress, object currency = null)
    {
        object currencyId = this.safeString(currency, "id");
        return new Dictionary<string, object>() {
            { "currency", this.safeCurrencyCode(this.safeString(depositAddress, "currency", currencyId)) },
            { "network", this.safeString(depositAddress, "networkType") },
            { "address", this.safeString2(depositAddress, "address", "reference") },
            { "tag", this.safeString(depositAddress, "paymentReference") },
            { "info", depositAddress },
        };
    }

    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name valr#fetchDeposits
        * @description fetch all deposits made to an account
        * @see https://docs.valr.com/#1061d8de-3792-4a0a-8ae6-715cb8a5179e
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch deposits for
        * @param {int} [limit] the maximum number of deposits structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        this.checkRequiredCurrencyCodeArgument("fetchDeposits", code);
        if (isTrue(this.isFiat(code)))
        {
            throw new NotSupported ((string)add(this.id, " fetchDeposits() is not supported yet for fiat currencies")) ;
        }
        object currency = this.safeCurrency(code);
        object currencyId = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        object response = await this.privateGetWalletCryptoCurrencyDepositHistory(this.extend(currencyId, parameters));
        // [
        //     {
        //       "currencyCode": "BTC",
        //       "receiveAddress": "2MvLmR6cd4YVDFAU8BTujKkzrV1dwFaNHup",
        //       "transactionHash": "fb588e3be006058c5853880421ef7241388270e2b506ce7ca553f8e5b797f628",
        //       "networkType": "Bitcoin",
        //       "amount": "0.01",
        //       "createdAt": "2019-03-01T14:36:53Z",
        //       "confirmations": 2,
        //       "confirmed": true,
        //       "confirmedAt": "2019-03-01T14:48:47.340347Z"
        //     },
        //     {
        //       "currencyCode": "BTC",
        //       "receiveAddress": "2MvLmR6cd4YVDFAU8BTujKkzrV1dwFaNHup",
        //       "transactionHash": "a0a70db6c1b2f84caa562e8523f0aaee83c73d1e9ff97e9ec2d6b36f4ad56f3e",
        //       "networkType": "Bitcoin",
        //       "amount": "0.11229885",
        //       "createdAt": "2019-01-11T08:54:20Z",
        //       "confirmations": 0,
        //       "confirmed": true,
        //       "confirmedAt": "2019-01-11T09:30:57.265843Z"
        //     }
        //   ]
        return this.parseTransactions(response);
    }

    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name valr#fetchWithdrawals
        * @see https://docs.valr.com/#d166dbf5-e922-4037-b0a7-5d490796662c
        * @description fetch history of withdrawals
        * @param {string} [code] unified currency code for the currency of the deposit/withdrawals, default is undefined
        * @param {int} [since] timestamp in ms of the earliest deposit/withdrawal, default is undefined
        * @param {int} [limit] max number of deposit/withdrawals to return, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a list of [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        this.checkRequiredCurrencyCodeArgument("fetchWithdrawals", code);
        if (isTrue(this.isFiat(code)))
        {
            throw new NotSupported ((string)add(this.id, " fetchWithdrawals() is not supported yet for fiat currencies")) ;
        }
        object currency = new Dictionary<string, object>() {
            { "currency", getValue(this.safeCurrency(code), "id") },
        };
        object response = await this.privateGetWalletCryptoCurrencyWithdrawHistory(this.extend(currency, parameters));
        // [
        //     {
        //       "currency": "BTC",
        //       "address": "invalidAddress123",
        //       "amount": "0.0001",
        //       "feeAmount": "0.0002",
        //       "confirmations": 0,
        //       "uniqueId": "2ab9dfce-7818-4812-9b33-fee7bd7c7c5a",
        //       "createdAt": "2019-04-20T14:30:26.950Z",
        //       "verified": true,
        //       "status": "Failed",
        //       "networkType": "Bitcoin"
        //     },
        //     {
        //       "currency": "BTC",
        //       "address": "mkHS9ne12qx9pS9VojpwU5xtRd4T7X7ZUt",
        //       "amount": "0.19974963",
        //       "feeAmount": "0.0002",
        //       "transactionHash": "a79535cc38f515d1c3ecac364057521ffece9ed0ed11667ba2b83bcc8c065994",
        //       "confirmations": 2,
        //       "lastConfirmationAt": "2019-03-12T08:08:13.879189",
        //       "uniqueId": "a243daf8-cc5d-4e61-9618-433e0d4c79ac",
        //       "createdAt": "2019-03-11T10:36:23.739Z",
        //       "verified": true,
        //       "status": "Complete",
        //       "networkType": "Bitcoin"
        //     },
        //     {
        //       "currency": "BTC",
        //       "address": "mkuKgijS7w4hjWL3Zs7kw7HQvM85a2F8RZ",
        //       "amount": "0.01",
        //       "feeAmount": "0.00055",
        //       "transactionHash": "87d8701d3b241cc6a32b10388ad5c6f8cf9a9336d9e9fcd2592ad84b57473eb9",
        //       "confirmations": 2,
        //       "lastConfirmationAt": "2019-01-12T08:55:14.692649",
        //       "uniqueId": "be612be3-06e3-4214-b81e-9bf8e645c28a",
        //       "createdAt": "2019-01-11T12:56:21.080Z",
        //       "verified": true,
        //       "status": "Processing",
        //       "networkType": "Bitcoin"
        //     }
        //   ]
        return this.parseTransactions(response);
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name valr#withdraw
        * @see https://docs.valr.com/#bb0ad4dc-a28d-41a3-8e59-5070bc589c5a
        * @see https://docs.valr.com/#fb4db187-530b-4632-b933-7bdfd192bcf5
        * @description make a withdrawal
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string} tag
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        this.checkRequiredCurrencyCodeArgument("fetchWithdrawals", code);
        object currency = this.safeCurrency(code);
        // todo: Include 'networkType' from default currency if none provided via params
        object response = null;
        if (isTrue(this.isFiat(code)))
        {
            object withdrawalBody = new Dictionary<string, object>() {
                { "currency", getValue(currency, "id") },
                { "linkedBankAccountId", address },
                { "amount", this.numberToString(amount) },
            };
            response = await this.privatePostWalletFiatCurrencyWithdraw(this.extend(withdrawalBody, parameters));
        } else
        {
            object withdrawalBody = new Dictionary<string, object>() {
                { "currency", getValue(currency, "id") },
                { "address", address },
                { "amount", this.numberToString(amount) },
            };
            response = await this.privatePostWalletCryptoCurrencyWithdraw(this.extend(withdrawalBody, parameters));
        }
        return this.parseTransaction(response);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        object timestamp = this.parse8601(this.safeString(transaction, "createdAt"));
        object code = this.safeCurrencyCode(this.safeString(transaction, "currencyCode"));
        object status = null;
        if (isTrue(this.safeBool(transaction, "confirmed")))
        {
            status = "ok";
        }
        object transactionType = null;
        if (isTrue(inOp(transaction, "receiveAddress")))
        {
            transactionType = "deposit";
        }
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", this.safeString(transaction, "id") },
            { "txid", this.safeString(transaction, "transactionHash") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "address", this.safeString(transaction, "receiveAddress") },
            { "addressFrom", null },
            { "addressTo", null },
            { "tag", null },
            { "tagFrom", null },
            { "tagTo", null },
            { "type", transactionType },
            { "amount", this.safeNumber(transaction, "amount") },
            { "currency", code },
            { "status", status },
            { "updated", this.parse8601(this.safeString(transaction, "confirmedAt")) },
            { "fee", null },
            { "network", this.safeString(transaction, "networkType") },
            { "comment", null },
            { "internal", null },
        };
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object partialPath = this.implodeParams(path, parameters);
        object url = add(add(getValue(getValue(this.urls, "api"), api), "/"), partialPath);
        object query = this.omit(parameters, this.extractParams(path));
        if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
        {
            if (isTrue(isTrue(isTrue(isEqual(method, "POST")) || isTrue(isEqual(method, "PUT"))) || isTrue(isEqual(method, "DELETE"))))
            {
                body = this.json(query);
            } else
            {
                url = add(url, add("?", this.urlencode(query)));
            }
        }
        object signHeaders = null;
        if (isTrue(isEqual(api, "private")))
        {
            object full_path = add(add(add("/v", this.version), "/"), partialPath);
            this.checkRequiredCredentials();
            object timestamp = ((object)this.milliseconds()).ToString();
            object message = add(add(timestamp, ((string)method).ToUpper()), full_path);
            if (isTrue(!isEqual(body, null)))
            {
                message = add(message, body);
            }
            object payloadBase64 = this.stringToBase64(message);
            object signature = this.hmac(this.base64ToBinary(payloadBase64), this.base64ToBinary(this.stringToBase64(this.secret)), sha512, "hex");
            signHeaders = new Dictionary<string, object>() {
                { "X-VALR-API-KEY", this.apiKey },
                { "X-VALR-SIGNATURE", signature },
                { "X-VALR-TIMESTAMP", timestamp },
            };
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", this.deepExtend(headers, signHeaders) },
        };
    }
}
