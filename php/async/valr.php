<?php

namespace ccxt\async;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\async\abstract\valr as Exchange;
use ccxt\ArgumentsRequired;
use ccxt\BadRequest;
use ccxt\BadSymbol;
use ccxt\NullResponse;
use ccxt\InvalidOrder;
use ccxt\NotSupported;
use ccxt\Precise;
use React\Async;
use React\Promise\PromiseInterface;

class valr extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'id' => 'valr',
            'name' => 'VALR',
            'countries' => array( 'ZA' ),
            'rateLimit' => 1000,
            'version' => '1',
            // 'comment' => 'This comment is optional',
            'has' => array(
                'CORS' => null,
                'spot' => true,
                'margin' => null,
                'swap' => null,
                'future' => null,
                'option' => null,
                'cancelAllOrders' => true,
                'cancelOrder' => true,
                'createMarketBuyOrderWithCost' => true,
                'createMarketSellOrderWithCost' => true,
                'createOrder' => true,
                'createPostOnlyOrder' => true,
                'fetchAccounts' => true,
                'fetchBalance' => true,
                'fetchClosedOrders' => true,
                'fetchCurrencies' => true,
                'fetchDepositAddress' => true,
                'fetchDeposits' => true,
                'fetchFundingLimits' => false,
                'fetchL3OrderBook' => true,
                'fetchLedger' => false,
                'fetchMyTrades' => true,
                'fetchOHLCV' => false,
                'fetchOpenOrders' => true,
                'fetchOrder' => true,
                'fetchOrderBook' => true,
                'fetchOrderBooks' => false,
                'fetchOrders' => false,
                'fetchPermissions' => true,
                'fetchStatus' => true,
                'fetchTicker' => true,
                'fetchTickers' => true,
                'fetchTime' => true,
                'fetchTrades' => true,
                'fetchTradingFees' => true,
                'fetchTransactions' => false,
                'fetchWithdrawals' => true,
                'transfer' => false,
                'withdraw' => true,
            ),
            'urls' => array(
                'logo' => null,
                'api' => array(
                    'public' => 'https://api.valr.com/v1/public',
                    'private' => 'https://api.valr.com/v1',
                ),
                'www' => 'https://www.valr.com',
                'doc' => array(
                    'https://docs.valr.com/',
                ),
                'fees' => 'https://support.valr.com/hc/en-us/articles/360015777451-What-are-VALR-s-charges',
                'referral' => array(
                    'url' => 'https://www.valr.com/invite/VAE2R2GV',
                ),
            ),
            'requiredCredentials' => array(
                'apiKey' => true,
                'secret' => true,
            ),
            'api' => array(
                'public' => array(
                    'get' => array(
                        '{pair}/orderbook',
                        '{pair}/orderbook/full',
                        'currencies',
                        'pairs',
                        'ordertypes',
                        '{pair}/ordertypes',
                        'marketsummary',
                        '{pair}/marketsummary',
                        '{pair}/markprice/buckets',
                        '{pair}/trades',
                        '{pair}/futures/funding/history',
                        'time',
                        'status',
                        'futures/info',
                    ),
                ),
                'private' => array(
                    'get' => array(
                        'account/api-keys/current',
                        'account/subaccounts',
                        'account/balances',
                        'account/balances/all',
                        'account/transactionhistory',
                        'account/{pair}/tradehistory',
                        'account/fees/trade',
                        'marketdata/{pair}/orderbook',
                        'marketdata/{pair}/orderbook/full',
                        'marketdata/{pair}/tradehistory',
                        'wallet/crypto/{currency}/deposit/address',
                        'wallet/crypto/{currency}/deposit/history',
                        'wallet/crypto/address-book',
                        'wallet/crypto/address-book/{currency}',
                        'wallet/crypto/{currency}/withdraw',
                        'wallet/crypto/{currency}/withdraw/{id}',
                        'wallet/crypto/{currency}/withdraw/history',
                        'wallet/fiat/{currency}/accounts/{id}',
                        'wallet/fiat/{currency}/accounts',
                        'wallet/fiat/{currency}/banks',
                        'wallet/fiat/{currency}/deposit/reference',
                        'wallet/fiat/{currency}/deposit/reference/{currency}',
                        'wallet/fiat/{currency}/auto-buy',
                        'wire/accounts',
                        'simple/{pair}/order/{id}',
                        'pay/limits',
                        'pay/payid',
                        'pay/history',
                        'pay/identifier/{identifier}',
                        'pay/transactionid/{id}',
                        'orders/{pair}/orderid/{id}',
                        'orders/{pair}/customerorderid/{id}',
                        'orders/open',
                        'orders/history',
                        'orders/history/summary/orderid/{id}',
                        'orders/history/summary/customerorderid/{id}',
                        'orders/history/detail/orderid/{id}',
                        'orders/history/detail/customerorderid/{id}',
                        'staking/balances/{currency}',
                        'staking/rates',
                        'staking/rates/{currency}',
                        'staking/rewards',
                        'staking/history',
                        'margin/status',
                        'margin/account/status',
                        'positions/open',
                        'positions/closed/summary',
                        'positions/closed',
                        'positions/history',
                        'positions/funding/history',
                        'borrows/{currency}/history',
                        'loans/rates',
                    ),
                    'post' => array(
                        'account/subaccount',
                        'account/subaccounts/transfer',
                        'wallet/crypto/{currency}/withdraw',
                        'wallet/fiat/{currency}/accounts',
                        'wallet/fiat/{currency}/withdraw',
                        'wire/withdrawals',
                        'simple/{pair}/quote',
                        'simple/{pair}/order',
                        'pay',
                        'orders/limit',
                        'orders/market',
                        'orders/stop/limit',
                        'batch/orders',
                        'staking/stake',
                        'staking/un-stake',
                    ),
                    'put' => array(
                        'pay/transactionid/{id}/reverse',
                        'orders/modify',
                        'margin/account/status',
                    ),
                    'delete' => array(
                        'wallet/fiat/{currency}/accounts/{id}',
                        'orders/order',
                        'orders',
                        'orders/{pair}',
                    ),
                ),
                'privateV2' => array(
                    'get' => array(
                        'margin/status',
                        'healthz',
                    ),
                    'post' => array(
                        'orders/market',
                        'orders/limit',
                        'orders/stop/limit',
                    ),
                    'put' => array(
                        'orders/modify',
                    ),
                    'delete' => array(
                        'orders/order',
                    ),
                ),
            ),
            'headers' => array(
                'Content-Type' => 'application/json',
            ),
            'fees' => array(
                'trading' => array(
                    'percentage' => true,
                    'maker' => $this->parse_number('-0.0001'),
                    'taker' => $this->parse_number('0.003'),
                ),
            ),
            'options' => array(
                'fiat' => array(
                    'ZAR' => 'ZAR',
                    'USD' => 'USD',
                ),
                'tradingFeesByPairType' => array(
                    'ZAR' => 0.001,
                    'PERP' => 0.0005,
                ),
            ),
        ));
    }

    public function check_required_symbol_argument(string $methodName, string $symbol) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' ' . $methodName . '() requires valid $symbol name');
        }
        if (gettype($symbol) !== 'string') {
            throw new ArgumentsRequired($this->id . ' ' . $methodName . '() requires valid string name for symbol');
        }
        $market = $this->safe_market($symbol);
        if ($market === null) {
            throw new BadSymbol($this->id . ' ' . $methodName . '() found no valid $market for $symbol => ' . $symbol);
        }
    }

    public function check_required_currency_code_argument(string $methodName, string $code) {
        if ($code === null) {
            throw new ArgumentsRequired($this->id . ' ' . $methodName . '() requires valid $currency $code name');
        }
        $currency = $this->safe_currency($code);
        if ($currency['id'] === null) {
            throw new BadRequest($this->id . ' ' . $methodName . '() found no valid $currency ID for $currency $code => ' . $code);
        }
    }

    public function is_fiat($code) {
        return (is_array($this->options['fiat']) && array_key_exists($code, $this->options['fiat']));
    }

    public function fetch_time($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * fetches the current integer timestamp in milliseconds from the exchange server
             * @see https://docs.valr.com/#95f84056-2ac7-4f92-a5d9-fd0d9c104f01
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {int} the current integer timestamp in milliseconds from the exchange server
             */
            $response = Async\await($this->publicGetTime ($params));
            return $this->parse8601($this->safe_string($response, 'time'));
        }) ();
    }

    public function fetch_status($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * @see https://docs.valr.com/#88ab52a2-d63b-48b2-8984-d0982baec40a
             * fetch $status of exchange
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} A ~@link https://docs.ccxt.com/#/?id=exchange-$status-structure exchange $status structure~
             */
            $response = Async\await($this->publicGetStatus ($params));
            $statusReport = $this->safe_string($response, 'status');
            $status = null;
            if ($statusReport === 'online') {
                $status = 'ok';
            } elseif ($statusReport === 'read-only') {
                $status = 'maintenance';
            }
            return array(
                'status' => $status,
                'updated' => null,
                'eta' => null,
                'url' => 'https://status->valr.com/',
                'info' => $response,
            );
        }) ();
    }

    public function fetch_currencies($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * @see https://docs.valr.com/#88ab52a2-d63b-48b2-8984-d0982baec40a
             * fetches all available $currencies on an exchange
             * @param array(array()) [$params=array()] extra parameters specific to the exchange API endpoint
             * @return {array} an associative dictionary of ~@link https://docs.ccxt.com/#/?id=$currency-structure Currency Structure~
             */
            $currencies = Async\await($this->publicGetCurrencies ($params));
            // array(
            //     array(
            //       "symbol" => "R",
            //       "isActive" => true,
            //       "shortName" => "ZAR",
            //       "longName" => "Rand",
            //       "decimalPlaces" => "2",
            //       "withdrawalDecimalPlaces" => "2",
            //       "collateral" => true,
            //       "collateralWeight" => "1"
            //     ),
            //     {
            //       "symbol" => "BTC",
            //       "isActive" => true,
            //       "shortName" => "BTC",
            //       "longName" => "Bitcoin",
            //       "decimalPlaces" => "8",
            //       "withdrawalDecimalPlaces" => "8",
            //       "collateral" => true,
            //       "collateralWeight" => "0.95",
            //       "defaultNetworkType" => "Bitcoin",
            //       "supportedNetworks" => array(
            //         array(
            //           "networkType" => "Bitcoin",
            //           "networkLongName" => "Bitcoin"
            //         }
            //       )
            //     ),
            //     {
            //       "symbol" => "ETH",
            //       "isActive" => true,
            //       "shortName" => "ETH",
            //       "longName" => "Ethereum",
            //       "decimalPlaces" => "18",
            //       "withdrawalDecimalPlaces" => "8",
            //       "collateral" => true,
            //       "collateralWeight" => "0.95",
            //       "defaultNetworkType" => "Ethereum",
            //       "supportedNetworks" => array(
            //         array(
            //           "networkType" => "Ethereum",
            //           "networkLongName" => "Ethereum"
            //         }
            //       )
            //     ),
            //     ...
            // )
            $result = array();
            for ($i = 0; $i < count($currencies); $i++) {
                $currency = $currencies[$i];
                $code = $this->safe_currency_code($this->safe_string($currency, 'shortName'));
                $precision = $this->safe_integer($currency, 'decimalPlaces');
                // Siacoin reports $precision of 24 which does not pass build test
                if (($precision !== null) && ($precision > 18)) {
                    $precision = 18;
                }
                $result[$code] = $this->safe_currency_structure(array(
                    'id' => $this->safe_string($currency, 'shortName'),
                    'code' => $code,
                    'info' => $currency,
                    'name' => $this->safe_string($currency, 'longName'),
                    'active' => $this->safe_string($currency, 'isActive'),
                    'precision' => $precision,
                    'withdraw' => (is_array($currency) && array_key_exists('supportedNetworks', $currency)) ? true : false,
                    'deposit' => (is_array($currency) && array_key_exists('supportedNetworks', $currency)) ? true : false,
                ));
            }
            return $result;
        }) ();
    }

    public function fetch_markets($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * retrieves data on all $markets for valr
             * @see https://docs.valr.com/#cfa57d7e-2106-4066-bc27-c10210b6aa82
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a list of ~@link https://docs.ccxt.com/#/?id=market-structure Market Structure~
             */
            $markets = Async\await($this->publicGetPairs ($params));
            // array(
            //     array('symbol' => 'ENJUSDC',
            //     'baseCurrency' => 'ENJ',
            //     'quoteCurrency' => 'USDC',
            //     'shortName' => 'ENJ/USDC',
            //     'active' => True,
            //     'minBaseAmount' => '3.5',
            //     'maxBaseAmount' => '3586.3',
            //     'minQuoteAmount' => '2',
            //     'maxQuoteAmount' => '5000',
            //     'tickSize' => '0.01',
            //     'baseDecimalPlaces' => '2',
            //     'marginTradingAllowed' => False,
            //     'currencyPairType' => 'SPOT'),
            //    array('symbol' => 'USDTZARPERP',
            //     'baseCurrency' => 'USDT',
            //     'quoteCurrency' => 'ZAR',
            //     'shortName' => 'USDT/ZARPERP',
            //     'active' => True,
            //     'minBaseAmount' => '1',
            //     'maxBaseAmount' => '250000',
            //     'minQuoteAmount' => '15',
            //     'maxQuoteAmount' => '5000000',
            //     'tickSize' => '0.01',
            //     'baseDecimalPlaces' => '3',
            //     'marginTradingAllowed' => False,
            //     'currencyPairType' => 'FUTURE'
            // ),
            // )
            return $this->parse_markets($markets);
        }) ();
    }

    public function parse_market($market): array {
        $base = $this->safe_currency_code($this->safe_string($market, 'baseCurrency'));
        $quote = $this->safe_currency_code($this->safe_string($market, 'quoteCurrency'));
        $currencyPairType = $this->safe_string($market, 'currencyPairType');
        $marketType = null;
        $spot = null;
        $swap = null;
        $symbol = $base . '/' . $quote;
        // required for future contracts
        $contract = false;
        $linear = null;
        $contractSize = null;
        $settle = null;
        $settleId = null;
        $taker = $this->safe_number($this->options['tradingFeesByPairType'], $quote, $this->fees['trading']['taker']);
        if ($currencyPairType === 'SPOT') {
            $marketType = 'spot';
            $spot = true;
        } elseif ($currencyPairType === 'FUTURE') {
            $taker = $this->safe_number($this->options['tradingFeesByPairType'], 'PERP', $this->fees['trading']['taker']);
            $marketType = 'swap';
            $spot = false;
            $swap = true;
            $symbol = $symbol . ':' . $quote;
            $contract = true;
            // Guess value
            $contractSize = $this->parse_number('1');
            // According to docs => https://support.valr.com/hc/en-us/articles/11078306427420-Perpetual-Futures-Trading-Guide
            $linear = true;
            $settle = $base;
            $settleId = $this->safe_string($market, 'baseCurrency');
            $symbol = $base . '/' . $quote . ':' . $settle;
        }
        return $this->safe_market_structure(array(
            'id' => $this->safe_string($market, 'symbol'),
            'symbol' => $symbol,
            'base' => $base,
            'quote' => $quote,
            'baseId' => $this->safe_string($market, 'baseCurrency'),
            'quoteId' => $this->safe_string($market, 'quoteCurrency'),
            'active' => $this->safe_bool($market, 'active'),
            'type' => $marketType,
            'spot' => $spot,
            'margin' => $this->safe_bool($market, 'marginTradingAllowed'),
            'future' => false,
            'swap' => $swap,
            'option' => false,
            'contract' => $contract,
            'percentage' => true,
            'tierBased' => false,
            'linear' => $linear,
            'contractSize' => $contractSize,
            'settle' => $settle,
            'settleId' => $settleId,
            // Setting defaults based on exchange not on response
            // These values are actually from private API call and can be overwriten with loadTradingFees
            'taker' => $taker,
            'maker' => $this->parse_number($this->fees['trading']['maker']),
            'precision' => array(
                'price' => $this->precision_from_string($this->safe_string($market, 'tickSize')),
                'amount' => $this->safe_integer($market, 'baseDecimalPlaces'),
            ),
            'limits' => array(
                'amount' => array(
                    'min' => $this->safe_float($market, 'minBaseAmount'),
                    'max' => $this->safe_float($market, 'maxBaseAmount'),
                ),
                'price' => array(
                    'min' => $this->safe_float($market, 'minQuoteAmount'),
                    'max' => $this->safe_float($market, 'maxQuoteAmount'),
                ),
            ),
            'info' => $market,
        ));
    }

    public function fetch_tickers(?array $symbols = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $params) {
            /**
             * @see https://docs.valr.com/#cd1f0448-3da3-44cf-b00d-91edd74e7e19
             * fetch market statistics for the multiple markets on the exchange
             * @param {string} [symbol] unified symbol of the market the order was made in
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a assiative array of ~@link https://docs.ccxt.com/#/?id=ticker-structure Ticker Structure~
             */
            Async\await($this->load_markets());
            $response = Async\await($this->publicGetMarketsummary ($params));
            // array(
            //     array(
            //       "currencyPair" => "BTCZAR",
            //       "askPrice" => "520000",
            //       "bidPrice" => "400000",
            //       "lastTradedPrice" => "400000",
            //       "previousClosePrice" => "400000",
            //       "baseVolume" => "0",
            //       "highPrice" => "400000",
            //       "lowPrice" => "0",
            //       "created" => "2022-06-12T18:06:05.001Z",
            //       "changeFromPrevious" => "0",
            //       "markPrice" => "400000"
            //     ),
            //     array(
            //       "currencyPair" => "ETHZAR",
            //       "askPrice" => "32158",
            //       "bidPrice" => "30899",
            //       "lastTradedPrice" => "30899",
            //       "previousClosePrice" => "30899",
            //       "baseVolume" => "0",
            //       "highPrice" => "30899",
            //       "lowPrice" => "0",
            //       "created" => "2022-06-12T18:06:05.001Z",
            //       "changeFromPrevious" => "0",
            //       "markPrice" => "30899"
            //     ),
            //     ...
            // )
            return $this->parse_tickers($response, $symbols, $params);
        }) ();
    }

    public function fetch_ticker(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * @see https://docs.valr.com/#89b446bb-60a6-42ff-aa09-29e4918a9eb0
             * fetch market statistics for a market on the exchange
             * @param {string} $symbol unified $symbol of the market the order was made in
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=ticker-structure Ticker Structure~
             */
            Async\await($this->load_markets());
            $this->check_required_symbol_argument($this->id . ' fetchTicker', $symbol);
            $marketId = $this->market_id($symbol);
            $request = array(
                'pair' => $marketId,
            );
            $response = Async\await($this->publicGetPairMarketsummary (array_merge($request, $params)));
            return $this->parse_ticker($response);
        }) ();
    }

    public function parse_ticker(array $ticker, ?array $market = null): array {
        $timestamp = $this->parse8601($this->safe_string($ticker, 'created'));
        $result = array(
            'symbol' => $this->safe_symbol($this->safe_string_2($ticker, 'currencyPair', 'currencyPairSymbol')),
            'info' => $ticker,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => $this->safe_string($ticker, 'highPrice'),
            'low' => $this->safe_string($ticker, 'lowPrice'),
            'bid' => $this->safe_string($ticker, 'bidPrice'),
            'ask' => $this->safe_string($ticker, 'askPrice'),
            'close' => $this->safe_string($ticker, ''),
            'last' => $this->safe_string($ticker, 'lastTradedPrice'),
            'open' => $this->safe_string($ticker, 'previousClosePrice'),
            'previousClose' => $this->safe_string($ticker, 'previousClosePrice'),
            'average' => $this->safe_string($ticker, 'markPrice'),
            'change' => null,
            'percentage' => $this->safe_string($ticker, 'changeFromPrevious'),
            'baseVolume' => $this->safe_string($ticker, 'baseVolume'),
            'quoteVolume' => $this->safe_string($ticker, 'quoteVolume'),
        );
        return $this->safe_ticker($result);
    }

    public function fetch_order_book(string $symbol, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * @see https://docs.valr.com/#89b446bb-60a6-42ff-aa09-29e4918a9eb0
             * fetches upto a maximum of the top 40 bids and asks in the order book
             * @param {string} $symbol unified $symbol of the market the order was made in
             * @param {Int} [$limit] the maximum number of order book structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=order-book-structure Order Book Structure~
             */
            Async\await($this->load_markets());
            $response = null;
            $this->check_required_symbol_argument('fetchOrderBook', $symbol);
            $params['pair'] = $this->market_id($symbol);
            if ($this->check_required_credentials(false)) {
                $response = Async\await($this->privateGetMarketdataPairOrderbook ($params));
            } else {
                $response = Async\await($this->publicGetPairOrderbook ($params));
            }
            $lastDateChange = $this->safe_string($response, 'LastChange');
            $timestamp = $this->parse8601($lastDateChange);
            return $this->parse_order_book($response, $symbol, $timestamp, 'Bids', 'Asks', 'price', 'quantity', 'orderCount');
        }) ();
    }

    public function fetch_l3_order_book(string $symbol, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * @see https://docs.valr.com/#c2acf6b9-dbba-4e6a-9075-a7907360812d
             * fetches all bids and asks in the order book
             * @param {string} $symbol unified $symbol of the market the order was made in
             * @param {Int} [$limit] the maximum number of order book structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=order-book-structure Order Book Structure~
             */
            Async\await($this->load_markets());
            $response = null;
            $this->check_required_symbol_argument('fetchOrderBook', $symbol);
            $params['pair'] = $this->market_id($symbol);
            if ($this->check_required_credentials(false)) {
                $response = Async\await($this->privateGetMarketdataPairOrderbookFull ($params));
            } else {
                $response = Async\await($this->publicGetPairOrderbookFull ($params));
            }
            $lastDateChange = $this->safe_string($response, 'LastChange');
            $timestamp = $this->parse8601($lastDateChange);
            return $this->parse_order_book($response, $symbol, $timestamp, 'Bids', 'Asks', 'price', 'quantity', 'id');
        }) ();
    }

    public function fetch_permissions($params = array ()) {
        /**
         * @see https://docs.valr.com/#af083ac6-0514-4979-9bab-f599ea1bed4f
         * returns the current API Key's information and $permissions->
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return an associative array with API enable $permissions
         */
        $this->check_required_credentials();
        $response = $this->privateGetAccountApiKeysCurrent ($params);
        $permissions = $this->safe_value($response, 'permissions');
        return array(
            'info' => $response,
            'created' => $this->parse8601($this->safe_string($response, 'addedAt')),
            'viewaccess' => $this->in_array('View access', $permissions),
            'trade' => $this->in_array('Trade', $permissions),
            'cryptwithdraws' => $this->in_array('Withdraw', $permissions),
            'fiatwithdraws' => $this->in_array('Link bank account', $permissions),
            'transfers' => $this->in_array('Internal Transfer', $permissions),
        );
    }

    public function fetch_balance($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * @see https://docs.valr.com/#60455ec7-ecdc-42ad-9a57-64941299da52
             * fetches the the balances in all currencies on the user account.
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a associative array of ~@link https://docs.ccxt.com/#/?id=balance-structure balance structure~
             */
            Async\await($this->load_markets());
            $response = Async\await($this->privateGetAccountBalances ($params));
            // array(
            //     array(
            //       "currency" => "USDT",
            //       "available" => "44822.97549155",
            //       "reserved" => "99.99925",
            //       "total" => "145612.43129945",
            //       "updatedAt" => "2023-04-25T09:00:04.406Z",
            //       "lendReserved" => "100000",
            //       "borrowReserved" => "689.4565579",
            //       "borrowedAmount" => "0",
            //       "totalInReference" => "7828.62533868",
            //       "totalInReferenceWeighted" => "7828.62533868",
            //       "referenceCurrency" => "USDC"
            //     ),
            //     {
            //       "currency" => "BTC",
            //       "available" => "0",
            //       "reserved" => "0",
            //       "total" => "-0.00101056",
            //       "updatedAt" => "2023-04-25T09:00:00.103Z",
            //       "lendReserved" => "0",
            //       "borrowReserved" => "0",
            //       "borrowedAmount" => "0.00101056",
            //       "totalInReference" => "-28.29568",
            //       "totalInReferenceWeighted" => "-27.588288",
            //       "referenceCurrency" => "USDC"
            //     }
            // )
            return $this->parse_balance($response);
        }) ();
    }

    public function parse_balance($balances): array {
        $result = array(
            'timestamp' => null,
            'datetime' => null,
            'info' => $balances,
        );
        for ($i = 0; $i < count($balances); $i++) {
            $balance = $balances[$i];
            $code = $this->safe_currency_code($this->safe_string($balance, 'currency'));
            $debt = Precise::string_add(
                $this->safe_string($balance, 'lendReserved'),
                $this->safe_string($balance, 'borrowReserved')
            );
            $result[$code] = array(
                'free' => $this->safe_float($balance, 'available'),
                'used' => $this->safe_float($balance, 'reserved'),
                'total' => $this->safe_float($balance, 'total'),
                'debt' => $debt,
            );
        }
        return $this->safe_balance($result);
    }

    public function fetch_accounts($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * @see https://docs.valr.com/#9443d7ce-c1c5-4597-b43e-d8fc2e7b49a7
             * fetch all the accounts associated with a profile
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a dictionary of ~@link https://docs.ccxt.com/#/?id=account-structure account structures~ indexed by the account type
             */
            $response = Async\await($this->privateGetAccountSubaccounts ($params));
            return $this->parse_accounts($response, $params);
        }) ();
    }

    public function parse_account($account) {
        $accountType = null;
        if ($this->safe_string($account, 'label') === 'Primary') {
            $accountType = 'main';
        } else {
            $accountType = 'subaccount';
        }
        // Todo => Use $account structure
        return array(
            'id' => $this->safe_string($account, 'id'),
            'type' => $accountType,
            'name' => $this->safe_string($account, 'label'),
            'code' => null,
            'info' => $account,
        );
    }

    public function fetch_order(string $id, ?string $symbol = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($id, $symbol, $params) {
            /**
             * @see https://docs.valr.com/#8d9252e1-ee27-495e-86ed-57458bdafd19
             * fetches information on an order made by the user
             * @param {string} $id order $id
             * @param {string} $symbol unified $symbol of the market the order was made in
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} An ~@link https://docs.ccxt.com/#/?$id=order-structure order structure~
             */
            Async\await($this->load_markets());
            $this->check_required_symbol_argument('fetchOrder', $symbol);
            $marketId = $this->market_id($symbol);
            $request = array(
                'id' => $id,
                'pair' => $marketId,
            );
            $response = Async\await($this->privateGetOrdersPairOrderidId (array_merge($request, $params)));
            // {
            //     "orderId" => "00fa7cb4-ea7c-4b8e-beed-dc63e226a6a2",
            //     "orderStatusType" => "Placed",
            //     "currencyPair" => "BTCZAR",
            //     "originalPrice" => "100000",
            //     "remainingQuantity" => "0.02",
            //     "originalQuantity" => "0.02",
            //     "orderSide" => "buy",
            //     "orderType" => "post-only limit",
            //     "failedReason" => "",
            //     "orderUpdatedAt" => "2024-03-12T09:42:37.766Z",
            //     "orderCreatedAt" => "2024-03-12T09:42:37.766Z",
            //     "timeInForce" => "GTC"
            // }
            return $this->parse_order($response);
        }) ();
    }

    public function fetch_open_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetches information on all order made by the user
             * @see https://docs.valr.com/#910bc498-b88d-48e8-b392-6cc94b8cb66d
             * @param {string} [$symbol] unified $symbol of the $market the order was made in
             * @param {int} [$since] the earliest time in ms to fetch orders for
             * @param {int} [$limit] the maximum number of order structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structure~
             */
            Async\await($this->load_markets());
            $response = Async\await($this->privateGetOrdersOpen ($params));
            // [array('orderId' => 'aa6dce9a-6acb-477f-9da8-223127e6b32d',
            // 'side' => 'buy',
            // 'remainingQuantity' => '0.02',
            // 'price' => '100000',
            // 'currencyPair' => 'BTCZAR',
            // 'createdAt' => '2024-03-12T07:14:17.275Z',
            // 'originalQuantity' => '0.02',
            // 'filledPercentage' => '0.00',
            // 'updatedAt' => '2024-03-12T07:14:17.275Z',
            // 'status' => 'Placed',
            // 'type' => 'post-only limit',
            // 'timeInForce' => 'GTC')]
            $market = null;
            if ($symbol !== null) {
                $market = $this->safe_value($this->markets, $symbol);
            }
            return $this->parse_orders($response, $market, $since, $limit, $params);
        }) ();
    }

    public function fetch_closed_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetches information on all closed order made by the user
             * @see https://docs.valr.com/#0d7cc0ff-b8ca-4e1f-980e-36d07672e53d
             * @param {string} [$symbol] unified $symbol of the $market the order was made in
             * @param {int} [$since] the earliest time in ms to fetch orders for
             * @param {int} [$limit] the maximum number of order structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a list of ~@link https://docs.ccxt.com/#/?id=order-structure order structure~
             */
            Async\await($this->load_markets());
            $response = Async\await($this->privateGetOrdersHistory ($params));
            // [array('orderId' => 'aa6dce9a-6acb-477f-9da8-223127e6b32d',
            //   'orderStatusType' => 'Cancelled',
            //   'currencyPair' => 'BTCZAR',
            //   'averagePrice' => '0',
            //   'originalPrice' => '100000',
            //   'remainingQuantity' => '0.02',
            //   'originalQuantity' => '0.02',
            //   'total' => '0',
            //   'totalFee' => '0',
            //   'feeCurrency' => 'BTC',
            //   'orderSide' => 'buy',
            //   'orderType' => 'post-only limit',
            //   'failedReason' => '',
            //   'orderUpdatedAt' => '2024-03-12T07:16:14.205Z',
            //   'orderCreatedAt' => '2024-03-12T07:14:17.275Z',
            //   'timeInForce' => 'GTC')]
            $market = null;
            if ($symbol !== null) {
                $market = $this->safe_value($this->markets, $symbol);
            }
            return $this->parse_orders($response, $market, $since, $limit, $params);
        }) ();
    }

    public function parse_order($order, ?array $market = null): array {
        $orderStatus = $this->safe_string($order, 'status');
        $status = null;
        if ($orderStatus === 'Placed' || $orderStatus === 'Active') {
            $status = 'open';
        } elseif ($orderStatus === 'Failed') {
            $status = 'canceled';
        } elseif ($orderStatus === 'Filled') {
            $status = 'closed';
        }
        $orderType = $this->safe_string_2($order, 'type', 'orderType');
        $type = null;
        if ($orderType !== null) {
            if ($orderType === 'market') {
                $type = 'market';
            } elseif (mb_strpos($orderType, 'limit')) {
                $type = 'limit';
            }
        }
        $datetime = $this->safe_string_2($order, 'createdAt', 'orderCreatedAt');
        $updateDatetime = $this->safe_string_2($order, 'updatedAt', 'orderUpdatedAt');
        $result = array(
            'id' => $this->safe_string($order, 'orderId'),
            'clientOrderId' => $this->safe_string($order, 'customerOrderId'),
            'timestamp' => $this->parse8601($datetime),
            'datetime' => $datetime,
            'symbol' => $this->safe_symbol($this->safe_string($order, 'currencyPair')),
            'type' => $type,
            'side' => $this->safe_string($order, 'side'),
            'lastTradeTimestamp' => null,
            'lastUpdateTimestamp' => $this->parse8601($updateDatetime),
            'price' => $this->safe_string($order, 'price'),
            'amount' => $this->safe_string($order, 'originalQuantity'),
            'cost' => null,
            'average' => $this->safe_string($order, 'averagePrice'),
            'filled' => null,
            'remaining' => $this->safe_string($order, 'remainingQuantity'),
            'timeInForce' => $this->safe_string($order, 'timeInForce'),
            'postOnly' => null,
            'trades' => null,
            'reduceOnly' => $this->safe_value($order, 'reduceOnly'),
            'triggerPrice' => null,
            'takeProfitPrice' => null,
            'stopLossPrice' => null,
            'status' => $status,
            'fee' => null,
            'info' => $order,
        );
        return $this->safe_order($result, $market);
    }

    public function create_order(string $symbol, string $type, string $side, float $amount, ?float $price = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $type, $side, $amount, $price, $params) {
            /**
             * @see https://docs.valr.com/#5beb7328-24ca-4d8a-84f2-6029725ad923
             * Create a trade order
             * @param {string} $symbol unified $symbol of the market to create an order in
             * @param {string} $type 'market' or 'limit'
             * @param {string} $side 'buy' or 'sell'
             * @param {float} $amount how much of currency you want to trade in units of base currency
             * @param {float} [$price] the $price at which the order is to be fullfilled, in units of the quote currency. If included in market order, use quote $amount
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @param {array} [$params->postOnly] if true will place a limit order and fail if matched immidiately
             * @param {array} [$params->customerOrderId] an optional field which can be specified by clients to track this order using their own internal order management systems
             * @param {array} [$params->allowMargin] Set to true for a margin / leverage trade
             * @return {array} an ~@link https://docs.ccxt.com/#/?id=order-structure order structure~ with only the id and $symbol added
             */
            Async\await($this->load_markets());
            $response = null;
            $this->check_required_symbol_argument('createOrder', $symbol);
            $marketId = $this->market_id($symbol);
            if ($side !== 'buy' && $side !== 'sell') {
                throw new InvalidOrder($this->id . ' createOrder() - "side" must be either "buy" or "sell".');
            }
            $body = array(
                'side' => strtoupper($side),
                'pair' => $marketId,
            );
            // Optional parameters
            if ($this->safe_string($params, 'customerOrderId')) {
                $body['customerOrderId'] = $this->safe_string($params, 'customerOrderId');
            }
            if ($this->safe_string($params, 'allowMargin')) {
                $body['allowMargin'] = $this->safe_string($params, 'allowMargin');
            }
            $this->omit($params, array( 'allowMargin', 'customerOrderId' ));
            if ($type === 'market') {
                if ($price) {
                    $body['quoteAmount'] = $amount;
                } else {
                    $body['baseAmount'] = $amount;
                }
                $this->omit($params, array( 'baseAmount', 'quoteAmount' ));
                $response = Async\await($this->privatePostOrdersMarket (array_merge($body, $params)));
            } elseif ($type === 'limit') {
                $body['price'] = $this->number_to_string($price);
                $body['quantity'] = $this->number_to_string($amount);
                if ($this->safe_string($params, 'postOnly')) {
                    $body['postOnly'] = $this->safe_bool($params, 'postOnly');
                    $this->omit($params, 'postOnly');
                }
                $response = Async\await($this->privatePostOrdersLimit (array_merge($body, $params)));
            } else {
                throw new InvalidOrder($this->id . ' createOrder() - "type" must be either "market" or "limit" to create an order.');
            }
            return $this->parse_order(array( 'orderId' => $this->safe_string($response, 'id'), 'currencyPair' => $marketId ));
        }) ();
    }

    public function create_orders(array $orders, $params = array ()): PromiseInterface {
        return Async\async(function () use ($orders, $params) {
            Async\await($this->load_markets());
            throw new NotSupported($this->id . ' createOrders() is not supported yet');
            // $response = await $this->privatePostBatchOrders ()
        }) ();
    }

    public function edit_order(string $id, string $symbol, string $type, string $side, ?float $amount = null, ?float $price = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($id, $symbol, $type, $side, $amount, $price, $params) {
            Async\await($this->load_markets());
            Async\await($this->cancel_order($id, $symbol));
            return Async\await($this->create_order($symbol, $type, $side, $amount, $price, $params));
            // TODO => Method currently in Beta
            // Async\await($this->privatePutOrdersModify ($this->entend (body, $params)));
        }) ();
    }

    public function cancel_order(string $id, ?string $symbol = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($id, $symbol, $params) {
            /**
             * @see https://docs.valr.com/#3d9ba169-7222-4c0f-ab08-87c22162c0c4
             * cancels an open order
             * @param {string} $id order $id
             * @param {string} $symbol unified $symbol of the market the order was made in
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} an ~@link https://docs.ccxt.com/#/?$id=order-structure order structure~ with only the $id and $symbol added
             */
            Async\await($this->load_markets());
            $this->check_required_symbol_argument('cancelOrder', $symbol);
            $marketId = $this->market_id($symbol);
            $orderFormat = array(
                'orderId' => $id,
                'pair' => $marketId,
            );
            Async\await($this->privateDeleteOrdersOrder (array_merge($orderFormat, $params)));
            return $this->parse_order(array( 'id' => $id, 'currencyPair' => $marketId ));
        }) ();
    }

    public function cancel_all_orders(?string $symbol = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            /**
             * @see https://docs.valr.com/#90822956-7e25-48a8-bd14-a83fb8766b46
             * cancels all an open order or all open orders on a specific market
             * @param {string} [$symbol] unified $symbol of the market the order was made in
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} an list of ~@link https://docs.ccxt.com/#/?id=order-structure order structure~ with only the id and option $symbol added
             */
            Async\await($this->load_markets());
            $response = null;
            if ($symbol === null) {
                $response = $this->privateDeleteOrders ($params);
            } else {
                $this->check_required_symbol_argument('cancelAllOrders', $symbol);
                $marketId = $this->market_id($symbol);
                $body = array(
                    'pair' => $marketId,
                );
                $response = Async\await($this->privateDeleteOrdersPair (array_merge($body, $params)));
                for ($i = 0; $i < count($response); $i++) {
                    $response[$i]['currencyPair'] = $marketId;
                }
            }
            return $this->parse_orders($response);
        }) ();
    }

    public function fetch_trades(string $symbol, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * @see https://docs.valr.com/#68ecbf66-c8ab-4460-a1f3-5b245b15877e
             * @see https://docs.valr.com/#8e9429c0-f43b-4483-a2be-d03cd1bbb230
             * get the list of most recent trades for a particular $symbol-> If API keys present, use private API call for improved rate limits
             * @param {string} $symbol unified $symbol of the market to fetch trades for
             * @param {int} [$since] timestamp in ms of the earliest trade to fetch
             * @param {int} [$limit] the maximum amount of trades to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {Trade[]} a list of ~@link https://docs.ccxt.com/#/?id=trade-structure trade structures~
             */
            Async\await($this->load_markets());
            $response = null;
            $this->check_required_symbol_argument('fetchTrades', $symbol);
            $params['pair'] = $this->market_id($symbol);
            if ($this->check_required_credentials(false)) {
                $response = Async\await($this->privateGetMarketdataPairTradehistory ($params));
                // array(
                //     array(
                //       "price" => "43023",
                //       "quantity" => "0.01971316",
                //       "currencyPair" => "BTCUSDC",
                //       "tradedAt" => "2024-02-07T12:48:40.256Z",
                //       "takerSide" => "sell",
                //       "sequenceId" => 1204770707632816000,
                //       "id" => "37e5fba7-c5b7-11ee-b1a8-c700095e5df0",
                //       "quoteVolume" => "848.11928268"
                //     ),
                //     array(
                //       "price" => "42909",
                //       "quantity" => "0.00005173",
                //       "currencyPair" => "BTCUSDC",
                //       "tradedAt" => "2024-02-07T12:24:22.818Z",
                //       "takerSide" => "buy",
                //       "sequenceId" => 1204764594694783000,
                //       "id" => "d33297ae-c5b3-11ee-b1a8-c700095e5df0",
                //       "quoteVolume" => "2.21968257"
                //     ),
                // )
            } else {
                $response = Async\await($this->publicGetPairTrades ($params));
                // array(
                //     array(
                //       "price" => "43064",
                //       "quantity" => "0.00079928",
                //       "currencyPair" => "BTCUSDC",
                //       "tradedAt" => "2024-02-05T07:47:04.625Z",
                //       "takerSide" => "sell",
                //       "sequenceId" => 1203970033324130300,
                //       "id" => "c13c5166-c3fa-11ee-b1a8-c700095e5df0",
                //       "quoteVolume" => "34.42019392"
                //     ),
                //     array(
                //       "price" => "43010",
                //       "quantity" => "0.0001",
                //       "currencyPair" => "BTCUSDC",
                //       "tradedAt" => "2024-02-05T07:39:40.198Z",
                //       "takerSide" => "buy",
                //       "sequenceId" => 1203968169262186500,
                //       "id" => "b8562435-c3f9-11ee-b1a8-c700095e5df0",
                //       "quoteVolume" => "4.301"
                //     ),
                // )
            }
            return $this->parse_trades($response, null, $since, $limit, $params);
        }) ();
    }

    public function fetch_my_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * @see https://docs.valr.com/#68ecbf66-c8ab-4460-a1f3-5b245b15877e
             * @see https://docs.valr.com/#8e9429c0-f43b-4483-a2be-d03cd1bbb230
             * get the list of most recent trades for a particular $symbol for the profile.
             * @param {string} $symbol unified $symbol of the market to fetch trades for
             * @param {int} [$since] timestamp in ms of the earliest trade to fetch
             * @param {int} [$limit] the maximum amount of trades to fetch
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {Trade[]} a list of ~@link https://docs.ccxt.com/#/?id=trade-structure trade structures~
             */
            Async\await($this->load_markets());
            $this->check_required_symbol_argument('fetchMyTrades', $symbol);
            $params['pair'] = $this->market_id($symbol);
            $response = Async\await($this->privateGetAccountPairTradehistory ($params));
            // array(
            //     array(
            //       "price" => "29001",
            //       "quantity" => "0.00137926",
            //       "currencyPair" => "BTCUSDC",
            //       "tradedAt" => "2024-02-07T06:00:30.180Z",
            //       "side" => "buy",
            //       "sequenceId" => 1204667988813283300,
            //       "id" => "32ad194e-c57e-11ee-9935-593da58a6690",
            //       "orderId" => "3fda280f-e87e-44c8-babf-852da844e514",
            //       "fee" => "0.000000413778",
            //       "feeCurrency" => "BTC"
            //     ),
            //     {'price' => '19.3017',
            //     'quantity' => '1',
            //     'currencyPair' => 'USDCZAR',
            //     'tradedAt' => '2024-02-27T14:46:44.852Z',
            //     'side' => 'sell',
            //     'sequenceId' => '1212048179894161409',
            //     'id' => '06e88b34-d57f-11ee-92bb-d59de6d96a53',
            //     'orderId' => '5ae9af1e-eb05-427e-af4f-50bcbd9dc8f1',
            //     'makerReward' => '0.0001',
            //     'makerRewardCurrency' => 'USDC'}
            // )
            return $this->parse_trades($response, null, $since, $limit, $params);
        }) ();
    }

    public function parse_trade(array $trade, ?array $market = null): array {
        $symbol = $this->safe_symbol($this->safe_string($trade, 'currencyPair'));
        $timestamp = $this->parse8601($this->safe_string($trade, 'tradedAt'));
        $takerOrMaker = null;
        $feeCost = $this->safe_number_2($trade, 'fee', 'makerReward');
        // $tradeType = null;
        if (is_array($trade) && array_key_exists('makerReward', $trade)) {
            $takerOrMaker = 'maker';
            $feeCost = ($feeCost) ? -$feeCost : $feeCost;
        } else {
            $takerOrMaker = 'taker';
        }
        $fee = array(
            'currency' => $this->safe_string_2($trade, 'feeCurrency', 'makerRewardCurrency'),
            'cost' => $feeCost,
            'rate' => null,
        );
        return $this->safe_trade(array(
            'info' => $trade,
            'timestamp' => $timestamp,
            'datetime' => $this->safe_string($trade, 'tradedAt'),
            'id' => $this->safe_string($trade, 'id'),
            'order' => $this->safe_string($trade, 'orderId'),
            'symbol' => $symbol,
            'type' => ($takerOrMaker === 'taker') ? 'market' : 'limit',
            'side' => $this->safe_string_2($trade, 'side', 'takerSide'),
            'amount' => $this->safe_number($trade, 'quantity'),
            'price' => $this->safe_number($trade, 'price'),
            'cost' => $this->safe_number($trade, 'quoteVolume'),
            'takerOrMaker' => $takerOrMaker,
            'fee' => $fee,
        ));
    }

    public function fetch_trading_fees($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            /**
             * @see https://docs.valr.com/#00502bc7-bf1e-40d5-b284-25fa719f0229
             * fetch the trading fees for multiple markets
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a dictionary of ~@link https://docs.ccxt.com/#/?id=fee-structure fee structures~ indexed by market symbols
             */
            Async\await($this->load_markets());
            $response = Async\await($this->privateGetAccountFeesTrade ($params));
            if (gettype($response) !== 'array' || array_keys($response) !== array_keys(array_keys($response))) {
                throw new NullResponse($this->id . ' ' . 'fetchTradingFees() received incorrect response');
            }
            $result = array();
            for ($i = 0; $i < count($response); $i++) {
                $tradeFee = $response[$i];
                $symbol = $this->safe_symbol($this->safe_string($tradeFee, 'currencyPair'));
                if ((is_array($tradeFee) && array_key_exists('makerPercentage', $tradeFee)) && (is_array($tradeFee) && array_key_exists('takerPercentage', $tradeFee))) {
                    $makerStr = $this->safe_string($tradeFee, 'makerPercentage');
                    $takerStr = $this->safe_string($tradeFee, 'takerPercentage');
                    $makerStr = ($makerStr) ? Precise::string_div($makerStr, '100') : null;
                    $takerStr = ($takerStr) ? Precise::string_div($takerStr, '100') : null;
                    $result[$symbol] = array(
                        'maker' => $this->parse_number($makerStr),
                        'taker' => $this->parse_number($takerStr),
                        'info' => $tradeFee,
                        'symbol' => $symbol,
                        'percentage' => true,
                        'tierBased' => false,
                    );
                } else {
                    // Trading pair only avialble on VALR simple buy/sell platform and not trading platform.
                    continue;
                }
            }
            return $result;
            // todo => Let fetchTradingFee only returned $symbol instead of all - requires update in Exchange.ts
            // todo => Update .market values with feeTrading values.
        }) ();
    }

    public function load_trading_fees($params = array ()) {
        return Async\async(function () use ($params) {
            Async\await($this->load_markets());
            $tradingFees = Async\await($this->fetch_trading_fees($params));
            $tradingFeesList = $this->to_array($tradingFees);
            for ($i = 0; $i < count($tradingFeesList); $i++) {
                $tradeFee = $tradingFeesList[$i];
                $symbol = $tradeFee['symbol'];
                if ($this->in_array($symbol, $this->markets)) {
                    $this->markets[$symbol]['taker'] = $tradeFee['taker'];
                    $this->markets[$symbol]['maker'] = $tradeFee['maker'];
                }
            }
        }) ();
    }

    public function fetch_deposit_address(string $code, $params = array ()) {
        return Async\async(function () use ($code, $params) {
            /**
             * @see https://docs.valr.com/#b10ea5dd-00cb-4c33-bb28-53104a8f1b7b
             * @see https://docs.valr.com/#619d83fa-f562-4ed3-a573-81afbafd2f1c
             * fetch the deposit address for a $currency associated with this account
             * @param {string} $code unified $currency $code
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} an ~@link https://docs.ccxt.com/#/?id=address-structure address structure~
             */
            Async\await($this->load_markets());
            $this->check_required_currency_code_argument('fetchDepositAddress', $code);
            $response = null;
            $currency = $this->safe_currency($code);
            $currencyId = array(
                'currency' => $currency['id'],
            );
            if ($this->is_fiat($code)) {
                $response = Async\await($this->privateGetWalletFiatCurrencyDepositReference (array_merge($currencyId, $params)));
                // array('reference' => 'USDGVVU6XR')
            } else {
                $response = Async\await($this->privateGetWalletCryptoCurrencyDepositAddress (array_merge($currencyId, $params)));
                // {'currency' => 'BTC',
                // 'address' => '3Af2LnWaUFS2wXmXQMugsEtnq7iJTEncfX',
                // 'networkType' => 'Bitcoin'}
            }
            return $this->parse_deposit_address($response, $currency);
        }) ();
    }

    public function parse_deposit_address($depositAddress, ?array $currency = null) {
        $currencyId = $this->safe_string($currency, 'id');
        return array(
            'currency' => $this->safe_currency_code($this->safe_string($depositAddress, 'currency', $currencyId)),
            'network' => $this->safe_string($depositAddress, 'networkType'),
            'address' => $this->safe_string_2($depositAddress, 'address', 'reference'),
            'tag' => $this->safe_string($depositAddress, 'paymentReference'),
            'info' => $depositAddress,
        );
    }

    public function fetch_deposits(?string $code = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($code, $since, $limit, $params) {
            /**
             * fetch all deposits made to an account
             * @see https://docs.valr.com/#1061d8de-3792-4a0a-8ae6-715cb8a5179e
             * @param {string} $code unified $currency $code
             * @param {int} [$since] the earliest time in ms to fetch deposits for
             * @param {int} [$limit] the maximum number of deposits structures to retrieve
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array[]} a list of ~@link https://docs.ccxt.com/#/?id=transaction-structure transaction structures~
             */
            Async\await($this->load_markets());
            $this->check_required_currency_code_argument('fetchDeposits', $code);
            if ($this->is_fiat($code)) {
                throw new NotSupported($this->id . ' fetchDeposits() is not supported yet for fiat currencies');
            }
            $currency = $this->safe_currency($code);
            $currencyId = array(
                'currency' => $currency['id'],
            );
            $response = Async\await($this->privateGetWalletCryptoCurrencyDepositHistory (array_merge($currencyId, $params)));
            // array(
            //     array(
            //       "currencyCode" => "BTC",
            //       "receiveAddress" => "2MvLmR6cd4YVDFAU8BTujKkzrV1dwFaNHup",
            //       "transactionHash" => "fb588e3be006058c5853880421ef7241388270e2b506ce7ca553f8e5b797f628",
            //       "networkType" => "Bitcoin",
            //       "amount" => "0.01",
            //       "createdAt" => "2019-03-01T14:36:53Z",
            //       "confirmations" => 2,
            //       "confirmed" => true,
            //       "confirmedAt" => "2019-03-01T14:48:47.340347Z"
            //     ),
            //     {
            //       "currencyCode" => "BTC",
            //       "receiveAddress" => "2MvLmR6cd4YVDFAU8BTujKkzrV1dwFaNHup",
            //       "transactionHash" => "a0a70db6c1b2f84caa562e8523f0aaee83c73d1e9ff97e9ec2d6b36f4ad56f3e",
            //       "networkType" => "Bitcoin",
            //       "amount" => "0.11229885",
            //       "createdAt" => "2019-01-11T08:54:20Z",
            //       "confirmations" => 0,
            //       "confirmed" => true,
            //       "confirmedAt" => "2019-01-11T09:30:57.265843Z"
            //     }
            //   )
            return $this->parse_transactions($response);
            // Todo - Update Exchange.ts fetchDeposits argument from symbol to $code parameter
        }) ();
    }

    public function fetch_withdrawals(?string $code = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($code, $since, $limit, $params) {
            /**
             * @see https://docs.valr.com/#d166dbf5-e922-4037-b0a7-5d490796662c
             * fetch history of withdrawals
             * @param {string} [$code] unified $currency $code for the $currency of the deposit/withdrawals, default is null
             * @param {int} [$since] timestamp in ms of the earliest deposit/withdrawal, default is null
             * @param {int} [$limit] max number of deposit/withdrawals to return, default is null
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a list of ~@link https://docs.ccxt.com/#/?id=transaction-structure transaction structure~
             */
            Async\await($this->load_markets());
            $this->check_required_currency_code_argument('fetchWithdrawals', $code);
            if ($this->is_fiat($code)) {
                throw new NotSupported($this->id . ' fetchWithdrawals() is not supported yet for fiat currencies');
            }
            $currency = array(
                'currency' => $this->safe_currency($code)['id'],
            );
            $response = Async\await($this->privateGetWalletCryptoCurrencyWithdrawHistory (array_merge($currency, $params)));
            // array(
            //     array(
            //       "currency" => "BTC",
            //       "address" => "invalidAddress123",
            //       "amount" => "0.0001",
            //       "feeAmount" => "0.0002",
            //       "confirmations" => 0,
            //       "uniqueId" => "2ab9dfce-7818-4812-9b33-fee7bd7c7c5a",
            //       "createdAt" => "2019-04-20T14:30:26.950Z",
            //       "verified" => true,
            //       "status" => "Failed",
            //       "networkType" => "Bitcoin"
            //     ),
            //     array(
            //       "currency" => "BTC",
            //       "address" => "mkHS9ne12qx9pS9VojpwU5xtRd4T7X7ZUt",
            //       "amount" => "0.19974963",
            //       "feeAmount" => "0.0002",
            //       "transactionHash" => "a79535cc38f515d1c3ecac364057521ffece9ed0ed11667ba2b83bcc8c065994",
            //       "confirmations" => 2,
            //       "lastConfirmationAt" => "2019-03-12T08:08:13.879189",
            //       "uniqueId" => "a243daf8-cc5d-4e61-9618-433e0d4c79ac",
            //       "createdAt" => "2019-03-11T10:36:23.739Z",
            //       "verified" => true,
            //       "status" => "Complete",
            //       "networkType" => "Bitcoin"
            //     ),
            //     {
            //       "currency" => "BTC",
            //       "address" => "mkuKgijS7w4hjWL3Zs7kw7HQvM85a2F8RZ",
            //       "amount" => "0.01",
            //       "feeAmount" => "0.00055",
            //       "transactionHash" => "87d8701d3b241cc6a32b10388ad5c6f8cf9a9336d9e9fcd2592ad84b57473eb9",
            //       "confirmations" => 2,
            //       "lastConfirmationAt" => "2019-01-12T08:55:14.692649",
            //       "uniqueId" => "be612be3-06e3-4214-b81e-9bf8e645c28a",
            //       "createdAt" => "2019-01-11T12:56:21.080Z",
            //       "verified" => true,
            //       "status" => "Processing",
            //       "networkType" => "Bitcoin"
            //     }
            //   )
            return $this->parse_transactions($response);
            // Todo - Update Exchange.ts fetchDeposits argument from symbol to $code parameter
        }) ();
    }

    public function withdraw(string $code, float $amount, string $address, $tag = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($code, $amount, $address, $tag, $params) {
            /**
             * @see https://docs.valr.com/#bb0ad4dc-a28d-41a3-8e59-5070bc589c5a
             * @see https://docs.valr.com/#fb4db187-530b-4632-b933-7bdfd192bcf5
             * make a withdrawal
             * @param {string} $code unified $currency $code
             * @param {float} $amount the $amount to withdraw
             * @param {string} $address the $address to withdraw to
             * @param {string} $tag
             * @param {array} [$params] extra parameters specific to the exchange API endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=transaction-structure transaction structure~
             */
            Async\await($this->load_markets());
            $this->check_required_currency_code_argument('fetchWithdrawals', $code);
            $currency = $this->safe_currency($code);
            // todo => Include 'networkType' from default $currency if none provided via $params
            $response = null;
            if ($this->is_fiat($code)) {
                $withdrawalBody = array(
                    'currency' => $currency['id'],
                    'linkedBankAccountId' => $address,
                    'amount' => $this->number_to_string($amount),
                );
                $response = Async\await($this->privatePostWalletFiatCurrencyWithdraw (array_merge($withdrawalBody, $params)));
            } else {
                $withdrawalBody = array(
                    'currency' => $currency['id'],
                    'address' => $address,
                    'amount' => $this->number_to_string($amount),
                );
                $response = Async\await($this->privatePostWalletCryptoCurrencyWithdraw (array_merge($withdrawalBody, $params)));
            }
            return $this->parse_transaction($response);
        }) ();
    }

    public function parse_transaction($transaction, ?array $currency = null): array {
        $timestamp = $this->parse8601($this->safe_string($transaction, 'createdAt'));
        $code = $this->safe_currency_code($this->safe_string($transaction, 'currencyCode'));
        $status = null;
        if ($this->safe_bool($transaction, 'confirmed')) {
            $status = 'ok';
        }
        $transactionType = null;
        if (is_array($transaction) && array_key_exists('receiveAddress', $transaction)) {
            $transactionType = 'deposit';
        }
        return array(
            'info' => $transaction,
            'id' => $this->safe_string($transaction, 'id'),
            'txid' => $this->safe_string($transaction, 'transactionHash'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'address' => $this->safe_string($transaction, 'receiveAddress'),
            'addressFrom' => null,
            'addressTo' => null,
            'tag' => null,
            'tagFrom' => null,
            'tagTo' => null,
            'type' => $transactionType,
            'amount' => $this->safe_number($transaction, 'amount'),
            'currency' => $code,
            'status' => $status,
            'updated' => $this->parse8601($this->safe_string($transaction, 'confirmedAt')),
            'fee' => null,
            'network' => $this->safe_string($transaction, 'networkType'),
            'comment' => null,
            'internal' => null,
        );
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $partialPath = $this->implode_params($path, $params);
        $url = $this->urls['api'][$api] . '/' . $partialPath;
        $query = $this->omit($params, $this->extract_params($path));
        if ($query) {
            if ($method === 'POST' || $method === 'PUT' || $method === 'DELETE') {
                $body = $this->json($query);
            } else {
                $url .= '?' . $this->urlencode($query);
            }
        }
        $signHeaders = null;
        if ($api === 'private') {
            $full_path = '/v' . $this->version . '/' . $partialPath;
            $this->check_required_credentials();
            $timestamp = (string) $this->milliseconds();
            $message = $timestamp . strtoupper($method) . $full_path;
            if ($body !== null) {
                $message .= $body;
            }
            $payloadBase64 = base64_encode($message);
            $signature = $this->hmac(
                base64_decode($payloadBase64),
                base64_decode(base64_encode($this->secret)),
                'sha512',
                'hex'
            );
            $signHeaders = array(
                // 'Content-Type' => 'application/json',
                'X-VALR-API-KEY' => $this->apiKey,
                'X-VALR-SIGNATURE' => $signature,
                'X-VALR-TIMESTAMP' => $timestamp,
            );
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $this->deep_extend($headers, $signHeaders) );
    }
}
