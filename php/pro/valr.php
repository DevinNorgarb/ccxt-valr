<?php

namespace ccxt\pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\ArgumentsRequired;
use ccxt\Precise;
use React\Async;
use React\Promise\PromiseInterface;

class valr extends \ccxt\async\valr {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'has' => array(
                'ws' => true,
                'watchTicker' => true,
                'watchTickers' => true,
                'watchOrderBook' => true,
                'watchOrderBookForSymbols' => true,
                'watchTrades' => true,
                'watchTradesForSymbols' => true,
                'watchBalance' => true,
                'watchOHLCV' => true,
                'watchOHLCVForSymbols' => true,
                'watchOrders' => true,
                'watchMyTrades' => true,
                'watchPositions' => false,
            ),
            'timeframes' => array(
                '1m' => 60,
                '5m' => 300,
                '15m' => 900,
                '30m' => 1800,
                '1h' => 3600,
                '6h' => 21600,
                '1d' => 86400,
            ),
            'urls' => array(
                'api' => array(
                    'ws' => array(
                        'trade' => 'wss://api.valr.com/ws/trade',
                        'account' => 'wss://api.valr.com/ws/account',
                    ),
                ),
            ),
            'options' => array(
            ),
            'streaming' => array(
                'keepAlive' => 30000,
            ),
        ));
    }

    public function watch_order_book(string $symbol, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $limit, $params) {
            Async\await($this->load_markets());
            $this->checkRequiredSymbolArgument ('watchOrderBook', $symbol);
            return Async\await($this->watch_order_book_for_symbols(array( $symbol ), $limit, $params));
        }) ();
    }

    public function watch_order_book_for_symbols(array $symbols, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $limit, $params) {
            Async\await($this->load_markets());
            $marketIds = $this->market_ids($symbols);
            if ($symbols === null || $marketIds === null) {
                throw new ArgumentsRequired($this->id . ' watchOrderBookForSymbols() requires valid symbol list');
            }
            $url = $this->urls['api']['ws']['trade'];
            $client = $this->authenticate($url);
            $messageHashes = array();
            for ($i = 0; $i < count($marketIds); $i++) {
                $messageHashes[] = 'AGGREGATED_ORDERBOOK_UPDATE:' . $marketIds[$i];
            }
            $subscriptionHashes = is_array($client->subscriptions) ? array_keys($client->subscriptions) : array();
            for ($i = 0; $i < count($subscriptionHashes); $i++) {
                $subscriptionHash = $subscriptionHashes[$i];
                if (mb_strpos($subscriptionHash, 'AGGREGATED_ORDERBOOK_UPDATE:') !== false) {
                    $subMarketId = $this->safe_string(explode(':', $subscriptionHash), 1);
                    if ($subMarketId && !$this->in_array($subMarketId, $marketIds)) {
                        $marketIds[] = $subMarketId;
                    }
                }
            }
            $message = array(
                'type' => 'SUBSCRIBE',
                'subscriptions' => array(
                    array(
                        'event' => 'AGGREGATED_ORDERBOOK_UPDATE',
                        'pairs' => $marketIds,
                    ),
                ),
            );
            $orderbook = Async\await($this->watch_multiple($url, $messageHashes, $message, $messageHashes));
            return $orderbook->limit ();
        }) ();
    }

    public function handle_order_book(Client $client, $message) {
        // {
        //     "type" => "AGGREGATED_ORDERBOOK_UPDATE",
        //     "currencyPairSymbol" => "PYUSDUSDT",
        //     "LastChange" => "2024-03-27T12:39:52.562Z",
        //     "SequenceNumber" => 173347
        //     "data":
        //     {
        //         "Asks":
        //         array(
        //             array(
        //                 "side" => "sell",
        //                 "quantity" => "495.26",
        //                 "price" => "0.99735",
        //                 "currencyPair" => "PYUSDUSDT",
        //                 "orderCount" => 1
        //             ),
        //             array(
        //                 "side" => "sell",
        //                 "quantity" => "11352.38",
        //                 "price" => "0.99775",
        //                 "currencyPair" => "PYUSDUSDT",
        //                 "orderCount" => 1
        //             ),
        //             array(
        //                 "side" => "sell",
        //                 "quantity" => "11925.87",
        //                 "price" => "0.99825",
        //                 "currencyPair" => "PYUSDUSDT",
        //                 "orderCount" => 1
        //             ),
        //         ),
        //         "Bids":
        //         array(
        //             array(
        //                 "side" => "buy",
        //                 "quantity" => "498.38",
        //                 "price" => "0.99727",
        //                 "currencyPair" => "PYUSDUSDT",
        //                 "orderCount" => 1
        //             ),
        //             array(
        //                 "side" => "buy",
        //                 "quantity" => "11316.78",
        //                 "price" => "0.99687",
        //                 "currencyPair" => "PYUSDUSDT",
        //                 "orderCount" => 1
        //             ),
        //             array(
        //                 "side" => "buy",
        //                 "quantity" => "11964.06",
        //                 "price" => "0.99637",
        //                 "currencyPair" => "PYUSDUSDT",
        //                 "orderCount" => 1
        //             ),
        //         )
        //     }
        // }
        $updateType = $this->safe_string($message, 'type');
        $marketId = $this->safe_string($message, 'currencyPairSymbol');
        $messageHash = $updateType . ':' . $marketId;
        $symbol = $this->safe_symbol($marketId);
        $data = $this->safe_value($message, 'data');
        $nonce = $this->safe_integer($data, 'SequenceNumber');
        $datetime = $this->safe_string($data, 'LastChange');
        $timestamp = $this->parse8601($datetime);
        $orderbook = $this->safe_value($this->orderbooks, $symbol);
        if ($orderbook === null) {
            $orderbook = $this->counted_order_book();
        }
        $snapshot = array(
            'asks' => $this->parse_ws_order_book_side($this->safe_value($data, 'Asks')),
            'bids' => $this->parse_ws_order_book_side($this->safe_value($data, 'Bids')),
            'symbol' => $symbol,
            'timestamp' => $timestamp,
            'datetime' => $datetime,
            'nonce' => $nonce,
        );
        // Using reset instead of update does not support update
        $orderbook->reset ($snapshot);
        $this->orderbooks[$symbol] = $orderbook;
        $client->resolve ($orderbook, $messageHash);
        // if ($this->verbose) {
        //     $this->log($this->iso8601($this->milliseconds()), 'handleOrderBook', $orderbook->limit ());
        // }
    }

    public function parse_ws_order_book_side($side) {
        $result = array();
        for ($i = 0; $i < count($side); $i++) {
            $result[] = [
                $this->safe_number($side[$i], 'price'),
                $this->safe_number($side[$i], 'quantity'),
                $this->safe_number($side[$i], 'orderCount'),
            ];
        }
        return $result;
    }

    public function watch_ticker(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            $this->checkRequiredSymbolArgument ('watchTicker', $symbol);
            $tickers = Async\await($this->watch_tickers(array( $symbol ), $params));
            return $this->safe_value($tickers, $symbol);
        }) ();
    }

    public function watch_tickers(?array $symbols = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $params) {
            Async\await($this->load_markets());
            $marketIds = $this->market_ids($symbols);
            if ($symbols === null || $marketIds === null) {
                throw new ArgumentsRequired($this->id . ' watchTickers() requires valid $symbol list');
            }
            $url = $this->urls['api']['ws']['trade'];
            $client = $this->authenticate($url);
            $messageHashes = array();
            for ($i = 0; $i < count($marketIds); $i++) {
                $messageHashes[] = 'MARKET_SUMMARY_UPDATE:' . $marketIds[$i];
            }
            $subscriptionHashes = is_array($client->subscriptions) ? array_keys($client->subscriptions) : array();
            for ($i = 0; $i < count($subscriptionHashes); $i++) {
                $subscriptionHash = $subscriptionHashes[$i];
                if (mb_strpos($subscriptionHash, 'MARKET_SUMMARY_UPDATE:') !== false) {
                    $subMarketId = $this->safe_string(explode(':', $subscriptionHash), 1);
                    if ($subMarketId && !$this->in_array($subMarketId, $marketIds)) {
                        $marketIds[] = $subMarketId;
                    }
                }
            }
            $message = array(
                'type' => 'SUBSCRIBE',
                'subscriptions' => array(
                    array(
                        'event' => 'MARKET_SUMMARY_UPDATE',
                        'pairs' => $marketIds,
                    ),
                ),
            );
            $ticker = Async\await($this->watch_multiple($url, $messageHashes, $message, $messageHashes));
            $symbol = $this->safe_string($ticker, 'symbol');
            $tickers = array();
            $tickers[$symbol] = $ticker;
            return $tickers;
        }) ();
    }

    public function handle_ticker(Client $client, $message) {
        // {
        //     "type" => "MARKET_SUMMARY_UPDATE",
        //     "currencyPairSymbol" => "BTCZAR",
        //     "data":
        //     {
        //         "currencyPairSymbol" => "BTCZAR",
        //         "askPrice" => "1291722",
        //         "bidPrice" => "1291721",
        //         "lastTradedPrice" => "1291722",
        //         "previousClosePrice" => "1262175",
        //         "baseVolume" => "18.03385304",
        //         "quoteVolume" => "22799989.56979442",
        //         "highPrice" => "1293659",
        //         "lowPrice" => "1243091",
        //         "created" => "2024-03-24T21:49:08.217Z",
        //         "changeFromPrevious" => "2.34",
        //         "markPrice" => "1291638"
        //     }
        // }
        $updateType = $this->safe_string($message, 'type');
        $marketId = $this->safe_string($message, 'currencyPairSymbol');
        $symbol = $this->symbol($marketId);
        $messageHash = $updateType . ':' . $marketId;
        $tickerWs = $this->safe_value($message, 'data');
        $ticker = $this->parse_ticker($tickerWs);
        $this->tickers[$symbol] = $ticker;
        $client->resolve ($ticker, $messageHash);
        // if ($this->verbose) {
        //     $this->log($this->iso8601($this->milliseconds()), 'handleTicker', $ticker);
        // }
    }

    public function watch_trades(string $symbol, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            $this->checkRequiredSymbolArgument ('watchTrades', $symbol);
            return Async\await($this->watch_trades_for_symbols(array( $symbol ), $since, $limit, $params));
        }) ();
    }

    public function watch_trades_for_symbols(array $symbols, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $since, $limit, $params) {
            Async\await($this->load_markets());
            $marketIds = $this->market_ids($symbols);
            if ($symbols === null || $marketIds === null) {
                throw new ArgumentsRequired($this->id . ' watchTradesForSymbols() requires valid symbol list');
            }
            $url = $this->urls['api']['ws']['trade'];
            $client = $this->authenticate($url);
            $messageHashes = array();
            for ($i = 0; $i < count($marketIds); $i++) {
                $messageHashes[] = 'NEW_TRADE:' . $marketIds[$i];
            }
            $subscriptionHashes = is_array($client->subscriptions) ? array_keys($client->subscriptions) : array();
            for ($i = 0; $i < count($subscriptionHashes); $i++) {
                $subscriptionHash = $subscriptionHashes[$i];
                if (mb_strpos($subscriptionHash, 'NEW_TRADE:') !== false) {
                    $subMarketId = $this->safe_string(explode(':', $subscriptionHash), 1);
                    if ($subMarketId && !$this->in_array($subMarketId, $marketIds)) {
                        $marketIds[] = $subMarketId;
                    }
                }
            }
            $message = array(
                'type' => 'SUBSCRIBE',
                'subscriptions' => array(
                    array(
                        'event' => 'NEW_TRADE',
                        'pairs' => $marketIds,
                    ),
                ),
            );
            $trades = Async\await($this->watch_multiple($url, $messageHashes, $message, $messageHashes));
            if ($this->newUpdates) {
                $first = $this->safe_value($trades, 0);
                $tradeSymbol = $this->safe_string($first, 'symbol');
                $limit = $trades->getLimit ($tradeSymbol, $limit);
            }
            return $this->filter_by_since_limit($trades, $since, $limit, 'timestamp', true);
        }) ();
    }

    public function handle_trades(Client $client, $message) {
        // {
        //     "type" => "NEW_TRADE",
        //     "currencyPairSymbol" => "BTCZAR",
        //     "data":
        //     {
        //         "price" => "1360468",
        //         "quantity" => "0.0004402",
        //         "currencyPair" => "BTCZAR",
        //         "tradedAt" => "2024-03-27T12:33:19.918Z",
        //         "takerSide" => "buy",
        //         "id" => "31934cc3-ec36-11ee-92bb-8f9d774e71b6"
        //     }
        // }
        $updateType = $this->safe_string($message, 'type');
        $marketId = $this->safe_string($message, 'currencyPairSymbol');
        $messageHash = $updateType . ':' . $marketId;
        $symbol = $this->safe_symbol($marketId);
        $data = $this->safe_value($message, 'data');
        $parsed = array(
            'timestamp' => $this->parse8601($this->safe_string($data, 'tradedAt')),
            'datetime' => $this->safe_string($data, 'tradedAt'),
            'id' => $this->safe_string($data, 'id'),
            'order' => null,
            'type' => null,
            'takerOrMaker' => null,
            'symbol' => $symbol,
            'price' => $this->safe_string($data, 'price'),
            'amount' => $this->safe_string($data, 'quantity'),
            'side' => $this->safe_string($data, 'takerSide'),
            'info' => $data,
            'fee' => null,
        );
        $trade = $this->safe_trade($parsed);
        $stored = $this->safe_value($this->trades, $symbol);
        if ($stored === null) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $stored = new ArrayCache ($limit);
            $this->trades[$symbol] = $stored;
        }
        $stored->append ($trade);
        $client->resolve ($stored, $messageHash);
        // if ($this->verbose) {
        //     $this->log($this->iso8601($this->milliseconds()), 'handleTrades', $trade);
        // }
    }

    public function watch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            Async\await($this->load_markets());
            $this->checkRequiredSymbolArgument ('watchOHLCV', $symbol);
            $symbolAndTimeframe = array( $symbol, $timeframe );
            $symbolsAndTimeframes = array( $symbolAndTimeframe );
            $candles = Async\await($this->watch_ohlcv_for_symbols($symbolsAndTimeframes, $since, $limit, $params));
            $candlesSymbol = $this->safe_value($candles, $symbol);
            return $this->safe_value($candlesSymbol, $timeframe);
        }) ();
    }

    public function watch_ohlcv_for_symbols(array $symbolsAndTimeframes, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($symbolsAndTimeframes, $since, $limit, $params) {
            Async\await($this->load_markets());
            $symbolsLength = count($symbolsAndTimeframes);
            if ($symbolsLength === 0 || gettype($symbolsAndTimeframes[0]) !== 'array' || array_keys($symbolsAndTimeframes[0]) !== array_keys(array_keys($symbolsAndTimeframes[0]))) {
                throw new ArgumentsRequired($this->id . ' watchOHLCVForSymbols() requires a an array of $symbols and timeframes, like  [["BTC/USDT", "1m"], ["LTC/USDT", "5m"]]');
            }
            $marketIds = array();
            $symbols = array();
            $messageHashes = array();
            for ($i = 0; $i < count($symbolsAndTimeframes); $i++) {
                $symbolAndTimeframe = $symbolsAndTimeframes[$i];
                $timeframe = $symbolAndTimeframe[1];
                if (($timeframe === null) || !(is_array($this->timeframes) && array_key_exists($timeframe, $this->timeframes))) {
                    throw new ArgumentsRequired($this->id . ' watchOHLCVForSymbols() requires supported $timeframe option');
                }
                $symbol = $symbolAndTimeframe[0];
                $marketId = $this->market_id($symbol);
                $this->checkRequiredSymbolArgument ('watchOHLCVForSymbols', $symbol);
                $messageHashes[] = 'NEW_TRADE_BUCKET_' . $timeframe . ':' . $marketId;
                if (!$this->in_array($symbol, $symbols)) {
                    $symbols[] = $symbol;
                    $marketIds[] = $marketId;
                }
            }
            if ($marketIds === null) {
                throw new ArgumentsRequired($this->id . ' watchTradesForSymbols() requires valid $symbol list');
            }
            $url = $this->urls['api']['ws']['trade'];
            $client = $this->authenticate($url);
            $subscriptionHashes = is_array($client->subscriptions) ? array_keys($client->subscriptions) : array();
            for ($i = 0; $i < count($subscriptionHashes); $i++) {
                $subscriptionHash = $subscriptionHashes[$i];
                if (mb_strpos($subscriptionHash, 'NEW_TRADE_BUCKET') !== false) {
                    $subMarketId = $this->safe_string(explode(':', $subscriptionHash), 1);
                    if ($subMarketId && !$this->in_array($subMarketId, $marketIds)) {
                        $marketIds[] = $subMarketId;
                    }
                }
            }
            $message = array(
                'type' => 'SUBSCRIBE',
                'subscriptions' => array(
                    array(
                        'event' => 'NEW_TRADE_BUCKET',
                        'pairs' => $marketIds,
                    ),
                ),
            );
            // call to watchMultiple only gets one of the multiple $symbolsAndTimeframes returned all arrive
            // at the same time. The rest are stored in seperate caches.
            list($symbolWs, $timeframeWs, $candles) = Async\await($this->watch_multiple($url, $messageHashes, $message, $messageHashes));
            // $symbolTimeframeCandles = array();
            if ($this->newUpdates) {
                // for ($i = 0; $i < count($symbols); $i++) {
                //     $symbolReq = $symbols[$i];
                //     $candleSymbol = $this->safe_dict($this->ohlcvs, $symbolReq);
                //     if ($candleSymbol !== null) {
                //         $candleStored = $this->safe_value($candleSymbol, $timeframeWs);
                //         if ($candleStored !== null) {
                //             $limitReg = $candles->getLimit ($symbolWs, $limit);
                //             $filtered = $this->filter_by_since_limit($candles, $since, $limit, 0, true);
                //             $symbolTimeframeCandles[$symbolReq] = array();
                //             $symbolTimeframeCandles[$symbolReq][$timeframeWs] = $filtered;
                //         }
                //     }
                // }
                $limit = $candles->getLimit ($symbolWs, $limit);
            }
            $filtered = $this->filter_by_since_limit($candles, $since, $limit, 0, true);
            return $this->create_ohlcv_object($symbolWs, $timeframeWs, $filtered);
        }) ();
    }

    public function handle_ohlcv(Client $client, $message) {
        // Only support $timeframe of 1m
        // {
        //     type => 'NEW_TRADE_BUCKET',
        //     currencyPairSymbol => 'BTCUSDC',
        //     $data => {
        //       currencyPairSymbol => 'BTCUSDC',
        //       bucketPeriodInSeconds => 60,
        //       startTime => '2024-04-05T09:03:00Z',
        //       open => '67310',
        //       high => '67310',
        //       low => '67310',
        //       close => '67310',
        //       volume => '0',
        //       quoteVolume => '0'
        //     }
        // }
        $updateType = $this->safe_string($message, 'type');
        $marketId = $this->safe_string($message, 'currencyPairSymbol');
        $symbol = $this->safe_symbol($marketId);
        $data = $this->safe_value($message, 'data');
        $period = $this->safe_integer($data, 'bucketPeriodInSeconds');
        $timeframe = $this->find_timeframe($period);
        $parsed = array(
            $this->parse8601($this->safe_string($data, 'startTime')),
            $this->safe_number($data, 'open'), // open
            $this->safe_number($data, 'high'), // high
            $this->safe_number($data, 'low'), // low
            $this->safe_number($data, 'close'), // close
            $this->safe_number($data, 'volume'), // volume
        );
        $this->ohlcvs[$symbol] = $this->safe_value($this->ohlcvs, $symbol, array());
        $stored = $this->safe_value($this->ohlcvs[$symbol], $timeframe);
        if ($stored === null) {
            $limit = $this->safe_integer($this->options, 'OHLCVLimit', 1000);
            $stored = new ArrayCacheByTimestamp ($limit);
            $this->ohlcvs[$symbol][$timeframe] = $stored;
        }
        $stored->append ($parsed);
        // for multiOHLCV we need special object, to other "multi"
        // methods, because OHLCV response item does not contain $symbol
        // or $timeframe, thus otherwise it would be unrecognizable
        $messageHash = $updateType . '_' . $timeframe . ':' . $marketId;
        $client->resolve (array( $symbol, $timeframe, $stored ), $messageHash);
        // if ($this->verbose) {
        //     $this->log($this->iso8601($this->milliseconds()), 'handleOHLCV', $symbol, $timeframe, $parsed);
        // }
    }

    public function watch_balance($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            Async\await($this->load_markets());
            $url = $this->urls['api']['ws']['account'];
            $messageHash = 'BALANCE_UPDATE';
            $this->authenticate($url);
            $balances = Async\await($this->watch($url, $messageHash));
            return $balances;
        }) ();
    }

    public function handle_balance(Client $client, $message) {
        $data = $this->safe_value($message, 'data');
        // {
        //     "type" => "BALANCE_UPDATE",
        //     "data":
        //     {
        //         "currency":
        //         array(
        //             "symbol" => "R",
        //             "decimalPlaces" => 2,
        //             "isActive" => "True",
        //             "shortName" => "ZAR",
        //             "longName" => "Rand",
        //             "supportedWithdrawDecimalPlaces" => 2,
        //             "collateral" => "True",
        //             "collateralWeight" => "0.99"
        //         ),
        //         "available" => "1022.05",
        //         "reserved" => "10",
        //         "total" => "1032.05",
        //         "updatedAt" => "2024-03-25T15:38:48.580Z",
        //         "lendReserved" => "0",
        //         "borrowCollateralReserved" => "0",
        //         "borrowedAmount" => "0",
        //         "totalInReference" => "53.31359999",
        //         "totalInReferenceWeighted" => "52.7804639901",
        //         "referenceCurrency" => "USDC"
        //     }
        // }
        list($code, $balance) = $this->parse_ws_balance($data);
        if ($this->balance === null) {
            $this->balance = array();
        }
        $this->balance['info'] = $this->safe_value($balance, 'info');
        $this->balance['datetime'] = $this->safe_string($balance, 'datetime');
        $this->balance['timestamp'] = $this->safe_string($balance, 'timestamp');
        if ($code !== null) {
            $this->balance[$code] = $this->safe_dict($balance, $code);
            $this->balance = $this->safe_balance($this->balance);
        }
        $updateType = $this->safe_string($message, 'type');
        $client->resolve ($balance, $updateType);
        // if ($this->verbose) {
        //     $this->log($this->iso8601($this->milliseconds()), 'handleBalance', $balance);
        // }
    }

    public function parse_ws_balance($balanceWs): mixed {
        $result = array(
            'timestamp' => $this->parse8601($this->safe_string($balanceWs, 'updatedAt')),
            'datetime' => $this->safe_string($balanceWs, 'updatedAt'),
            'info' => $balanceWs,
        );
        $currency = $this->safe_value($balanceWs, 'currency');
        $code = $this->safe_currency_code($this->safe_string($currency, 'shortName'));
        $debt = Precise::string_add(
            $this->safe_string($balanceWs, 'lendReserved'),
            $this->safe_string($balanceWs, 'borrowReserved')
        );
        if ($code !== null) {
            $result[$code] = array(
                'free' => $this->safe_float($balanceWs, 'available'),
                'used' => $this->safe_float($balanceWs, 'reserved'),
                'total' => $this->safe_float($balanceWs, 'total'),
                'debt' => $debt,
            );
        }
        return array( $code, $result );
    }

    public function watch_my_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            Async\await($this->load_markets());
            $url = $this->urls['api']['ws']['account'];
            $messageHash = 'NEW_ACCOUNT_TRADE';
            if ($symbol) {
                $messageHash = $messageHash . ':' . $symbol;
            }
            $this->authenticate($url);
            $trades = Async\await($this->watch($url, $messageHash));
            if ($this->newUpdates) {
                $limit = $trades->getLimit ($symbol, $limit);
            }
            return $this->filter_by_symbol_since_limit($trades, $symbol, $since, $limit, true);
        }) ();
    }

    public function handle_my_trades(Client $client, $message) {
        // {
        //     "type" => "NEW_ACCOUNT_TRADE",
        //     "currencyPairSymbol" => "BTCZAR",
        //     "data" => {
        //       "price" => "9500",
        //       "quantity" => "0.00105263",
        //       "currencyPair" => "BTCZAR",
        //       "tradedAt" => "2019-04-25T20:36:53.426Z",
        //       "side" => "buy",
        //       "orderId":"d5a81b99-fabf-4be1-bc7c-1a00d476089d",
        //       "id":"7a2b5560-5a71-4640-9e4b-d659ed26278a"
        //     }
        //   }
        $marketId = $this->safe_string($message, 'currencyPairSymbol');
        $symbol = $this->safe_symbol($marketId);
        $tradeMessage = $this->safe_dict($message, 'data');
        $timestamp = $this->parse8601($this->safe_string($tradeMessage, 'tradedAt'));
        $myTrade = $this->safe_trade(array(
            'info' => $tradeMessage,
            'timestamp' => $timestamp,
            'datetime' => $this->safe_string($tradeMessage, 'tradedAt'),
            'id' => $this->safe_string($tradeMessage, 'id'),
            'order' => $this->safe_string($tradeMessage, 'orderId'),
            'symbol' => $symbol,
            'side' => $this->safe_string($tradeMessage, 'side'),
            'amount' => $this->safe_number($tradeMessage, 'quantity'),
            'price' => $this->safe_number($tradeMessage, 'price'),
        ));
        // watch All symbols
        $cachedTrades = $this->myTrades;
        if ($cachedTrades === null) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $cachedTrades = new ArrayCacheBySymbolById ($limit);
            $this->myTrades = $cachedTrades;
        }
        $updateType = $this->safe_string($message, 'type');
        $messageHashSymbol = $updateType . ':' . $symbol;
        $cachedTrades->append ($myTrade);
        $client->resolve ($cachedTrades, $updateType);
        // watch specific $symbol
        $client->resolve ($cachedTrades, $messageHashSymbol);
        // if ($this->verbose) {
        //     $this->log($this->iso8601($this->milliseconds()), 'handleMyTrades', $myTrade);
        // }
    }

    public function watch_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            Async\await($this->load_markets());
            $url = $this->urls['api']['ws']['account'];
            $messageHashes = array(
                // 'INSTANT_ORDER_COMPLETED',  // New Simple Buy/Sell executed
                // New order added to open $orders
                'OPEN_ORDERS_UPDATE',
                'ORDER_STATUS_UPDATE',
                // {
                //     "type" => "ORDER_STATUS_UPDATE",
                //     "data":
                //     {
                //         "orderId" => "0967a400-fcb3-45bd-8f4a-e2b0872f53a8",
                //         "orderStatusType" => "Cancelled",
                //         "currencyPair" => "BTCZAR",
                //         "originalPrice" => "2000000",
                //         "remainingQuantity" => "0.00001",
                //         "originalQuantity" => "0.00001",
                //         "orderSide" => "sell",
                //         "orderType" => "post-only $limit",
                //         "failedReason" => "",
                //         "orderUpdatedAt" => "2024-04-01T16:01:41.456Z",
                //         "orderCreatedAt" => "2024-04-01T16:00:31.074Z",
                //         "executedPrice" => "0",
                //         "executedQuantity" => "0",
                //         "executedFee" => "0"
                //     }
                // }
            );
            $this->authenticate($url);
            if ($symbol) {
                for ($i = 0; $i < count($messageHashes); $i++) {
                    $messageHashes[$i] = $messageHashes[$i] . ':' . $symbol;
                }
            }
            $orders = Async\await($this->watch_multiple($url, $messageHashes));
            if ($this->newUpdates) {
                $limit = $orders->getLimit ($symbol, $limit);
            }
            return $this->filter_by_symbol_since_limit($orders, $symbol, $since, $limit);
        }) ();
    }

    public function handle_orders(Client $client, $message) {
        // if ($this->verbose) {
        //     $this->log($this->iso8601($this->milliseconds()), 'handleOrders', $message);
        // }
        $messageHash = $this->safe_string($message, 'type');
        $data = $this->safe_value($message, 'data');
        $results = array();
        $messageHashesSymbol = array();
        $ordersMessage = array();
        if (gettype($data) === 'array' && array_keys($data) === array_keys(array_keys($data))) {
            $ordersMessage = $this->array_concat($ordersMessage, $data);
        } else {
            $ordersMessage[] = $data;
        }
        for ($i = 0; $i < count($ordersMessage); $i++) {
            $orderWs = $this->parse_ws_order($ordersMessage[$i]);
            $results[] = $orderWs;
            $symbol = $this->safe_string($orderWs, 'symbol');
            // $orderId = $this->safe_string(parsed, 'id');
            if ($symbol !== null) {
                $messageHashSymbol = $messageHash . ':' . $symbol;
                if (!$this->in_array($messageHashesSymbol, $messageHashesSymbol)) {
                    $messageHashesSymbol[] = $messageHashSymbol;
                }
                if ($this->orders === null) {
                    $limit = $this->safe_integer($this->options, 'ordersLimit', 1000);
                    $this->orders = new ArrayCacheBySymbolById ($limit);
                }
                $cachedOrders = $this->orders;
                // $orders = $this->safe_value($cachedOrders->hashmap, $symbol, array());
                // $order = $this->safe_value($orders, $orderId);
                // if ($order !== null) {
                // Use $data from existing $order before updating $orders
                // }
                $cachedOrders->append ($orderWs);
            }
        }
        $client->resolve ($this->orders, $messageHash);
        for ($i = 0; $i < count($messageHashesSymbol); $i++) {
            $client->resolve ($this->orders, $messageHashesSymbol[$i]);
        }
    }

    public function parse_ws_order($order, $market = null) {
        // OPEN_ORDERS_UPDATE : New $order added to open orders
        // array(
        //     array(
        //         "orderId" => "38511e49-a755-4f8f-a2b1-232bae6967dc",
        //         "side" => "sell",
        //         "quantity" => "0.1",
        //         "price" => "10000",
        //         "currencyPair" => "BTCZAR"
        //         "createdAt" => "2019-04-17T19:51:35.776Z",
        //         "originalQuantity" => "0.1",
        //         "filledPercentage" => "0.00",
        //         "type" => "post-only limit",
        //         "status" => "placed",
        //         "updatedAt" => "2019-04-17T19:51:35.776Z",
        //         "timeInForce" => "GTC",
        //         "customerOrderId" => ""
        //     ),
        //     array(
        //         "orderId" => "3f759a40-09ee-44bd-a5aa-29836bbaab1a",
        //         "side" => "sell",
        //         "quantity" => "0.04",
        //         "price" => "10000",
        //         "currencyPair" => "BTCZAR"
        //         "createdAt" => "2019-04-17T19:51:35.776Z",
        //         "originalQuantity" => "0.1",
        //         "filledPercentage" => "60.00",
        //         "customerOrderId" => "3"
        //         "type" => "post-only limit",
        //         "status" => "placed",
        //         "updatedAt" => "2019-04-17T19:51:35.776Z",
        //         "timeInForce" => "GTC",
        //     ),
        // )
        // OPEN_ORDERS_UPDATE : Open $order modified
        // array(
        //     array(
        //         "orderId":"6eaf85b7-7e69-4e26-9664-33a8f23bfb4f",
        //         "side":"buy",
        //         "quantity":"0.0002",
        //         "price":"29300",
        //         "currencyPair":"BTCUSDC",
        //         "createdAt":"2023-10-24T13:33:43.503Z",
        //         "originalQuantity":"0.0002",
        //         "filledPercentage":"0.00",
        //         "customerOrderId":"MyLimit1234",
        //         "type":"limit",
        //         "status":"Order Modified",
        //         "updatedAt":"2023-10-24T13:36:42.660Z",
        //         "timeInForce":"GTC"
        //     ),
        // )
        // ORDER_STATUS_UPDATE : Order $status has been updated
        // {
        //     "orderId" => "9135e74e-bd4f-4aec-ba1f-d38897826cda",
        //     "orderStatusType" => "Cancelled",
        //     "currencyPair" => "BTCZAR",
        //     "originalPrice" => "2100000",
        //     "remainingQuantity" => "0.00002",
        //     "originalQuantity" => "0.00002",
        //     "orderSide" => "sell",
        //     "orderType" => "post-only limit",
        //     "failedReason" => "None",
        //     "orderUpdatedAt" => "2024-04-01T16:14:00.963Z",
        //     "orderCreatedAt" => "2024-04-01T16:01:55.985Z",
        //     "executedPrice" => "0",
        //     "executedQuantity" => "0",
        //     "executedFee" => "0"
        // }
        // {
        //     "orderId" => "bf17d427-f9e8-44ef-82c1-4ed94c5f4f7f",
        //     "orderStatusType" => "Filled",
        //     "currencyPair" => "BTCZAR",
        //     "originalPrice" => "1335001",
        //     "remainingQuantity" => "0",
        //     "originalQuantity" => "0.00001",
        //     "orderSide" => "sell",
        //     "orderType" => "post-only limit",
        //     "failedReason" => "",
        //     "orderUpdatedAt" => "2024-04-01T16:14:54.716Z",
        //     "orderCreatedAt" => "2024-04-01T16:13:53.400Z",
        //     "executedPrice" => "1335001",
        //     "executedQuantity" => "0.00001",
        //     "executedFee" => "0"
        // }
        $orderStatus = $this->safe_string_2($order, 'status', 'orderStatusType');
        $status = null;
        if ($orderStatus === 'Placed' || $orderStatus === 'Order Modified') {
            $status = 'open';
        } elseif ($orderStatus === 'Cancelled' || $orderStatus === 'Failed') {
            $status = 'canceled';
        } elseif ($orderStatus === 'Filled') {
            $status = 'closed';
        }
        $orderTypeReceived = $this->safe_string($order, 'type');
        $typeOrder = null;
        $postOnly = null;
        if ($orderTypeReceived !== null) {
            if ($this->in_array('limit', $orderTypeReceived)) {
                $typeOrder = 'limit';
                if ($this->in_array('post-only', $orderTypeReceived)) {
                    $postOnly = true;
                } else {
                    $postOnly = false;
                }
            }
        }
        $filledPercentage = $this->safe_string($order, 'filledPercentage');
        $remaining = $this->safe_string($order, 'remainingQuantity');
        $amount = $this->safe_string($order, 'originalQuantity');
        $filled = null;
        if ($remaining === null && $filledPercentage !== null) {
            $filled = Precise::string_mul($amount, $filledPercentage);
        }
        return $this->safe_order(array(
            'timestamp' => $this->parse8601($this->safe_string_2($order, 'createdAt', 'orderCreatedAt')),
            'datetime' => $this->safe_string_2($order, 'createdAt', 'orderCreatedAt'),
            'id' => $this->safe_string($order, 'orderId'),
            'clientOrderId' => $this->safe_string($order, 'customerOrderId'),
            'symbol' => $this->safe_symbol($this->safe_string($order, 'currencyPair')),
            'status' => $status,
            'type' => $typeOrder,
            'side' => $this->safe_string_2($order, 'side', 'orderSide'),
            'price' => $this->safe_string_2($order, 'price', 'originalPrice'),
            'amount' => $amount,
            'average' => $this->safe_string($order, 'averagePrice'),
            'filled' => $filled,
            'remaining' => $remaining,
            'lastUpdateTimestamp' => $this->parse8601($this->safe_string_2($order, 'updatedAt', 'orderUpdatedAt')),
            'timeInForce' => $this->safe_string($order, 'timeInForce'),
            'postOnly' => $postOnly,
            'info' => $order,
        ));
    }

    public function watch_transactions(?string $code = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        return Async\async(function () use ($code, $since, $limit, $params) {
            Async\await($this->load_markets());
            $url = $this->urls['api']['ws']['account'];
            $messageHashes = array(
                'ORDER_PROCESSED',
                // {
                //     "type" => "ORDER_PROCESSED",
                //     "data" => {
                //       "orderId" => "247dc157-bb5b-49af-b476-2f613b780697",
                //       "success" => true,
                //       "failureReason" => ""
                //     }
                // }
                'MODIFY_ORDER_OUTCOME', // Order modified
                // {
                //     "type" => "MODIFY_ORDER_OUTCOME",
                //     "data" => {
                //       "success":true,
                //       "orderId":"6eaf85b7-7e69-4e26-9664-33a8f23bfb4f",
                //       "customerOrderId":"MyLimit1234",
                //       "modifyRequestId":"e0632f4e-7dab-11ee-95c0-07ba663465ab"
                //     }
                // }
                'FAILED_CANCEL_ORDER',
                // {
                //     "type" => "FAILED_CANCEL_ORDER",
                //     "data" => {
                //         "orderId" => "247dc157-bb5b-49af-b476-2f613b780697",
                //         "message" => "An error occurred while cancelling your order."
                //     }
                // }
            );
            $this->authenticate($url);
            $result = Async\await($this->watch_multiple($url, $messageHashes));
            return $result;
        }) ();
    }

    public function handle_transaction(Client $client, $message) {
        $messageHash = $this->safe_string($message, 'type');
        $results = array();
        $results[] = $message;
        $client->resolve ($results, $messageHash);
        // if ($this->verbose) {
        //     $this->log($this->iso8601($this->milliseconds()), 'handleTransaction', $results);
        // }
    }

    public function ping(Client $client) {
        return array( 'type' => 'PING' );
    }

    public function handle_pong(Client $client, $message) {
        $client->lastPong = $this->milliseconds();
        // array('type' => 'PONG')
        // if ($this->verbose) {
        //     $this->log($this->iso8601($client->lastPong), 'handlePong', $client->url, $message);
        // }
        return $message;
    }

    public function handle_message(Client $client, $message) {
        if ($message === '') {
            // $this->log($this->iso8601($this->milliseconds()), 'Empty Message');
            return;
        }
        $methods = array(
            'AGGREGATED_ORDERBOOK_UPDATE' => array($this, 'handle_order_book'),
            // 'FULL_ORDERBOOK_UPDATE' => array($this, 'log'),
            // array("type":"FULL_ORDERBOOK_UPDATE","currencyPairSymbol":"PYUSDUSDT","data":array("LastChange":1711543154427,"Asks":[array("Price":"0.99732","Orders":[array("orderId":"041200ae-2849-4660-93bd-ff6b8d1ebd39","quantity":"0")]),array("Price":"0.99766","Orders":[array("orderId":"b6c577f1-bf4d-4963-9e9e-aa87499ee93c","quantity":"0")]),array("Price":"0.99816","Orders":[array("orderId":"3d9ed086-0079-4cda-b052-5fbbf5fd6966","quantity":"0")]),array("Price":"1.00315","Orders":[array("orderId":"992b1ba2-0a58-404f-9710-2fa617a908fe","quantity":"0")]),array("Price":"1.00817","Orders":[array("orderId":"f0b97400-f7ed-43f1-be48-6097e71e5a25","quantity":"0")]),array("Price":"1.01321","Orders":[array("orderId":"82555657-3968-42e7-b4d2-b9866b2e59aa","quantity":"0")])],"Bids":[array("Price":"0.99726","Orders":[array("orderId":"cb1a92fa-0db4-42db-bca8-0fee32cdfc8d","quantity":"0")]),array("Price":"0.99678","Orders":[array("orderId":"8d4a8efd-f871-40d6-8c63-576d20e7777c","quantity":"0")]),array("Price":"0.99628","Orders":[array("orderId":"517a2a39-dfe9-4605-938b-4564313012a4","quantity":"0")]),array("Price":"0.99129","Orders":[array("orderId":"e4851eeb-25d4-4383-891c-7361c3e1bb10","quantity":"0")]),array("Price":"0.98633","Orders":[array("orderId":"6a45081f-37e3-4977-9e91-68a95505698f","quantity":"0")]),array("Price":"0.98139","Orders":[array("orderId":"6837f9fb-f4fc-434a-914b-0e25e9d1585a","quantity":"0")])],"SequenceNumber":173335,"Checksum":492550141))
            'MARKET_SUMMARY_UPDATE' => array($this, 'handle_ticker'),
            'NEW_TRADE_BUCKET' => array($this, 'handle_ohlcv'),
            'NEW_TRADE' => array($this, 'handle_trades'),
            // 'MARK_PRICE_UPDATE' => array($this, 'log'),
            // Used for instant buy/sell orders not for exchange.
            // array("type":"MARK_PRICE_UPDATE","currencyPairSymbol":"BTCZAR","data":array("price":"1360201"))
            'PONG' => array($this, 'handle_pong'),
            'BALANCE_UPDATE' => array($this, 'handle_balance'),
            'NEW_ACCOUNT_TRADE' => array($this, 'handle_my_trades'),
            'OPEN_ORDERS_UPDATE' => array($this, 'handle_orders'),
            'ORDER_STATUS_UPDATE' => array($this, 'handle_orders'),
            'ORDER_PROCESSED' => array($this, 'handle_transaction'),
            'MODIFY_ORDER_OUTCOME' => array($this, 'handle_transaction'),
            'FAILED_CANCEL_ORDER' => array($this, 'handle_transaction'),
        );
        $eventType = $this->safe_string($message, 'type');
        $method = $this->safe_value($methods, $eventType);
        // $subscriptions = is_array($client->subscriptions) ? array_values($client->subscriptions) : array();
        // $messageHash = is_array($client->messageHash) ? array_values($client->messageHash) : array()
        if ($method) {
            // if ($client->verbose) {
            //     $this->log($this->iso8601($this->milliseconds()), 'handleMessage', 'eventType:', $eventType, 'method:', $method);
            // }
            $method($client, $message);
        // } else {
        //     if ($this->verbose) {
        //         $this->log($this->iso8601($this->milliseconds()), 'handleMessage => Unknown $message->', $message);
        //     }
        }
    }

    public function authenticate(string $url): Client {
        if (($this->clients !== null) && (is_array($this->clients) && array_key_exists($url, $this->clients))) {
            return $this->client($url);
        }
        $this->check_required_credentials();
        $timestamp = (string) $this->milliseconds();
        $urlParts = explode('/', $url);
        $partsLength = count($urlParts);
        $path = '/' . $this->safe_string($urlParts, $partsLength - 2) . '/' . $this->safe_string($urlParts, $partsLength - 1);
        $message = $timestamp . 'GET' . $path;
        $payloadBase64 = base64_encode($message);
        $signature = $this->hmac(
            base64_decode($payloadBase64),
            base64_decode(base64_encode($this->secret)),
            'sha512',
            'hex'
        );
        // Can't pass $headers directly to array($this, 'client'). Use $this->options['ws'] instead.
        $defaultOptions = array(
            'ws' => array(
                'options' => array(
                    'headers' => array(),
                ),
            ),
        );
        $this->extend_exchange_options($defaultOptions);
        $originalHeaders = $this->options['ws']['options']['headers'];
        $headers = array(
            'X-VALR-API-KEY' => $this->apiKey,
            'X-VALR-SIGNATURE' => $signature,
            'X-VALR-TIMESTAMP' => $timestamp,
        );
        $this->options['ws']['options']['headers'] = $headers;
        $client = $this->client($url);
        $this->options['ws']['options']['headers'] = $originalHeaders;
        return $client;
    }
}
