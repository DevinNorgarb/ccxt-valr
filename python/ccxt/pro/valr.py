# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

import ccxt.async_support
from ccxt.async_support.base.ws.cache import ArrayCache, ArrayCacheBySymbolById, ArrayCacheByTimestamp
from ccxt.base.types import Balances, Int, Order, OrderBook, Str, Ticker, Tickers, Trade
from ccxt.async_support.base.ws.client import Client
from typing import List
from typing import Any
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.precise import Precise


class valr(ccxt.async_support.valr):

    def describe(self):
        return self.deep_extend(super(valr, self).describe(), {
            'has': {
                'ws': True,
                'watchTicker': True,
                'watchTickers': True,
                'watchOrderBook': True,
                'watchOrderBookForSymbols': True,
                'watchTrades': True,
                'watchTradesForSymbols': True,
                'watchBalance': True,
                'watchOHLCV': True,
                'watchOHLCVForSymbols': True,
                'watchOrders': True,
                'watchMyTrades': True,
                'watchPositions': False,
            },
            'timeframes': {
                '1m': 60,
                '5m': 300,
                '15m': 900,
                '30m': 1800,
                '1h': 3600,
                '6h': 21600,
                '1d': 86400,
            },
            'urls': {
                'api': {
                    'ws': {
                        'trade': 'wss://api.valr.com/ws/trade',
                        'account': 'wss://api.valr.com/ws/account',
                    },
                },
            },
            'options': {
            },
            'streaming': {
                'keepAlive': 30000,
            },
        })

    async def watch_order_book(self, symbol: str, limit: Int = None, params={}) -> OrderBook:
        await self.load_markets()
        self.checkRequiredSymbolArgument('watchOrderBook', symbol)
        return await self.watch_order_book_for_symbols([symbol], limit, params)

    async def watch_order_book_for_symbols(self, symbols: List[str], limit: Int = None, params={}) -> OrderBook:
        await self.load_markets()
        marketIds = self.market_ids(symbols)
        if symbols is None or marketIds is None:
            raise ArgumentsRequired(self.id + ' watchOrderBookForSymbols() requires valid symbol list')
        url = self.urls['api']['ws']['trade']
        client = self.authenticate(url)
        messageHashes = []
        for i in range(0, len(marketIds)):
            messageHashes.append('AGGREGATED_ORDERBOOK_UPDATE:' + marketIds[i])
        subscriptionHashes = list(client.subscriptions.keys())
        for i in range(0, len(subscriptionHashes)):
            subscriptionHash = subscriptionHashes[i]
            if subscriptionHash.find('AGGREGATED_ORDERBOOK_UPDATE:') >= 0:
                subMarketId = self.safe_string(subscriptionHash.split(':'), 1)
                if subMarketId and not self.in_array(subMarketId, marketIds):
                    marketIds.append(subMarketId)
        message = {
            'type': 'SUBSCRIBE',
            'subscriptions': [
                {
                    'event': 'AGGREGATED_ORDERBOOK_UPDATE',
                    'pairs': marketIds,
                },
            ],
        }
        orderbook = await self.watch_multiple(url, messageHashes, message, messageHashes)
        return orderbook.limit()

    def handle_order_book(self, client: Client, message):
        # {
        #     "type": "AGGREGATED_ORDERBOOK_UPDATE",
        #     "currencyPairSymbol": "PYUSDUSDT",
        #     "LastChange": "2024-03-27T12:39:52.562Z",
        #     "SequenceNumber": 173347
        #     "data":
        #     {
        #         "Asks":
        #         [
        #             {
        #                 "side": "sell",
        #                 "quantity": "495.26",
        #                 "price": "0.99735",
        #                 "currencyPair": "PYUSDUSDT",
        #                 "orderCount": 1
        #             },
        #             {
        #                 "side": "sell",
        #                 "quantity": "11352.38",
        #                 "price": "0.99775",
        #                 "currencyPair": "PYUSDUSDT",
        #                 "orderCount": 1
        #             },
        #             {
        #                 "side": "sell",
        #                 "quantity": "11925.87",
        #                 "price": "0.99825",
        #                 "currencyPair": "PYUSDUSDT",
        #                 "orderCount": 1
        #             },
        #         ],
        #         "Bids":
        #         [
        #             {
        #                 "side": "buy",
        #                 "quantity": "498.38",
        #                 "price": "0.99727",
        #                 "currencyPair": "PYUSDUSDT",
        #                 "orderCount": 1
        #             },
        #             {
        #                 "side": "buy",
        #                 "quantity": "11316.78",
        #                 "price": "0.99687",
        #                 "currencyPair": "PYUSDUSDT",
        #                 "orderCount": 1
        #             },
        #             {
        #                 "side": "buy",
        #                 "quantity": "11964.06",
        #                 "price": "0.99637",
        #                 "currencyPair": "PYUSDUSDT",
        #                 "orderCount": 1
        #             },
        #         ]
        #     }
        # }
        updateType = self.safe_string(message, 'type')
        marketId = self.safe_string(message, 'currencyPairSymbol')
        messageHash = updateType + ':' + marketId
        symbol = self.safe_symbol(marketId)
        data = self.safe_value(message, 'data')
        nonce = self.safe_integer(data, 'SequenceNumber')
        datetime = self.safe_string(data, 'LastChange')
        timestamp = self.parse8601(datetime)
        orderbook = self.safe_value(self.orderbooks, symbol)
        if orderbook is None:
            orderbook = self.counted_order_book()
        snapshot = {
            'asks': self.parse_ws_order_book_side(self.safe_value(data, 'Asks')),
            'bids': self.parse_ws_order_book_side(self.safe_value(data, 'Bids')),
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': datetime,
            'nonce': nonce,
        }
        # Using reset instead of update does not support update
        orderbook.reset(snapshot)
        self.orderbooks[symbol] = orderbook
        client.resolve(orderbook, messageHash)
        # if self.verbose:
        #     self.log(self.iso8601(self.milliseconds()), 'handleOrderBook', orderbook.limit())
        # }

    def parse_ws_order_book_side(self, side):
        result = []
        for i in range(0, len(side)):
            result.append([
                self.safe_number(side[i], 'price'),
                self.safe_number(side[i], 'quantity'),
                self.safe_number(side[i], 'orderCount'),
            ])
        return result

    async def watch_ticker(self, symbol: str, params={}) -> Ticker:
        self.checkRequiredSymbolArgument('watchTicker', symbol)
        tickers = await self.watch_tickers([symbol], params)
        return self.safe_value(tickers, symbol)

    async def watch_tickers(self, symbols: List[str] = None, params={}) -> Tickers:
        await self.load_markets()
        marketIds = self.market_ids(symbols)
        if symbols is None or marketIds is None:
            raise ArgumentsRequired(self.id + ' watchTickers() requires valid symbol list')
        url = self.urls['api']['ws']['trade']
        client = self.authenticate(url)
        messageHashes = []
        for i in range(0, len(marketIds)):
            messageHashes.append('MARKET_SUMMARY_UPDATE:' + marketIds[i])
        subscriptionHashes = list(client.subscriptions.keys())
        for i in range(0, len(subscriptionHashes)):
            subscriptionHash = subscriptionHashes[i]
            if subscriptionHash.find('MARKET_SUMMARY_UPDATE:') >= 0:
                subMarketId = self.safe_string(subscriptionHash.split(':'), 1)
                if subMarketId and not self.in_array(subMarketId, marketIds):
                    marketIds.append(subMarketId)
        message = {
            'type': 'SUBSCRIBE',
            'subscriptions': [
                {
                    'event': 'MARKET_SUMMARY_UPDATE',
                    'pairs': marketIds,
                },
            ],
        }
        ticker = await self.watch_multiple(url, messageHashes, message, messageHashes)
        symbol = self.safe_string(ticker, 'symbol')
        tickers = {}
        tickers[symbol] = ticker
        return tickers

    def handle_ticker(self, client: Client, message):
        # {
        #     "type": "MARKET_SUMMARY_UPDATE",
        #     "currencyPairSymbol": "BTCZAR",
        #     "data":
        #     {
        #         "currencyPairSymbol": "BTCZAR",
        #         "askPrice": "1291722",
        #         "bidPrice": "1291721",
        #         "lastTradedPrice": "1291722",
        #         "previousClosePrice": "1262175",
        #         "baseVolume": "18.03385304",
        #         "quoteVolume": "22799989.56979442",
        #         "highPrice": "1293659",
        #         "lowPrice": "1243091",
        #         "created": "2024-03-24T21:49:08.217Z",
        #         "changeFromPrevious": "2.34",
        #         "markPrice": "1291638"
        #     }
        # }
        updateType = self.safe_string(message, 'type')
        marketId = self.safe_string(message, 'currencyPairSymbol')
        symbol = self.symbol(marketId)
        messageHash = updateType + ':' + marketId
        tickerWs = self.safe_value(message, 'data')
        ticker = self.parse_ticker(tickerWs)
        self.tickers[symbol] = ticker
        client.resolve(ticker, messageHash)
        # if self.verbose:
        #     self.log(self.iso8601(self.milliseconds()), 'handleTicker', ticker)
        # }

    async def watch_trades(self, symbol: str, since: Int = None, limit: Int = None, params={}) -> List[Trade]:
        self.checkRequiredSymbolArgument('watchTrades', symbol)
        return await self.watch_trades_for_symbols([symbol], since, limit, params)

    async def watch_trades_for_symbols(self, symbols: List[str], since: Int = None, limit: Int = None, params={}) -> List[Trade]:
        await self.load_markets()
        marketIds = self.market_ids(symbols)
        if symbols is None or marketIds is None:
            raise ArgumentsRequired(self.id + ' watchTradesForSymbols() requires valid symbol list')
        url = self.urls['api']['ws']['trade']
        client = self.authenticate(url)
        messageHashes = []
        for i in range(0, len(marketIds)):
            messageHashes.append('NEW_TRADE:' + marketIds[i])
        subscriptionHashes = list(client.subscriptions.keys())
        for i in range(0, len(subscriptionHashes)):
            subscriptionHash = subscriptionHashes[i]
            if subscriptionHash.find('NEW_TRADE:') >= 0:
                subMarketId = self.safe_string(subscriptionHash.split(':'), 1)
                if subMarketId and not self.in_array(subMarketId, marketIds):
                    marketIds.append(subMarketId)
        message = {
            'type': 'SUBSCRIBE',
            'subscriptions': [
                {
                    'event': 'NEW_TRADE',
                    'pairs': marketIds,
                },
            ],
        }
        trades = await self.watch_multiple(url, messageHashes, message, messageHashes)
        if self.newUpdates:
            first = self.safe_value(trades, 0)
            tradeSymbol = self.safe_string(first, 'symbol')
            limit = trades.getLimit(tradeSymbol, limit)
        return self.filter_by_since_limit(trades, since, limit, 'timestamp', True)

    def handle_trades(self, client: Client, message):
        # {
        #     "type": "NEW_TRADE",
        #     "currencyPairSymbol": "BTCZAR",
        #     "data":
        #     {
        #         "price": "1360468",
        #         "quantity": "0.0004402",
        #         "currencyPair": "BTCZAR",
        #         "tradedAt": "2024-03-27T12:33:19.918Z",
        #         "takerSide": "buy",
        #         "id": "31934cc3-ec36-11ee-92bb-8f9d774e71b6"
        #     }
        # }
        updateType = self.safe_string(message, 'type')
        marketId = self.safe_string(message, 'currencyPairSymbol')
        messageHash = updateType + ':' + marketId
        symbol = self.safe_symbol(marketId)
        data = self.safe_value(message, 'data')
        parsed = {
            'timestamp': self.parse8601(self.safe_string(data, 'tradedAt')),
            'datetime': self.safe_string(data, 'tradedAt'),
            'id': self.safe_string(data, 'id'),
            'order': None,
            'type': None,
            'takerOrMaker': None,
            'symbol': symbol,
            'price': self.safe_string(data, 'price'),
            'amount': self.safe_string(data, 'quantity'),
            'side': self.safe_string(data, 'takerSide'),
            'info': data,
            'fee': None,
        }
        trade = self.safe_trade(parsed)
        stored = self.safe_value(self.trades, symbol)
        if stored is None:
            limit = self.safe_integer(self.options, 'tradesLimit', 1000)
            stored = ArrayCache(limit)
            self.trades[symbol] = stored
        stored.append(trade)
        client.resolve(stored, messageHash)
        # if self.verbose:
        #     self.log(self.iso8601(self.milliseconds()), 'handleTrades', trade)
        # }

    async def watch_ohlcv(self, symbol: str, timeframe='1m', since: Int = None, limit: Int = None, params={}) -> List[list]:
        await self.load_markets()
        self.checkRequiredSymbolArgument('watchOHLCV', symbol)
        symbolAndTimeframe = [symbol, timeframe]
        symbolsAndTimeframes = [symbolAndTimeframe]
        candles = await self.watch_ohlcv_for_symbols(symbolsAndTimeframes, since, limit, params)
        candlesSymbol = self.safe_value(candles, symbol)
        return self.safe_value(candlesSymbol, timeframe)

    async def watch_ohlcv_for_symbols(self, symbolsAndTimeframes: List[List[str]], since: Int = None, limit: Int = None, params={}):
        await self.load_markets()
        symbolsLength = len(symbolsAndTimeframes)
        if symbolsLength == 0 or not isinstance(symbolsAndTimeframes[0], list):
            raise ArgumentsRequired(self.id + ' watchOHLCVForSymbols() requires a an array of symbols and timeframes, like  [["BTC/USDT", "1m"], ["LTC/USDT", "5m"]]')
        marketIds = []
        symbols = []
        messageHashes = []
        for i in range(0, len(symbolsAndTimeframes)):
            symbolAndTimeframe = symbolsAndTimeframes[i]
            timeframe = symbolAndTimeframe[1]
            if (timeframe is None) or not (timeframe in self.timeframes):
                raise ArgumentsRequired(self.id + ' watchOHLCVForSymbols() requires supported timeframe option')
            symbol = symbolAndTimeframe[0]
            marketId = self.market_id(symbol)
            self.checkRequiredSymbolArgument('watchOHLCVForSymbols', symbol)
            messageHashes.append('NEW_TRADE_BUCKET_' + timeframe + ':' + marketId)
            if not self.in_array(symbol, symbols):
                symbols.append(symbol)
                marketIds.append(marketId)
        if marketIds is None:
            raise ArgumentsRequired(self.id + ' watchTradesForSymbols() requires valid symbol list')
        url = self.urls['api']['ws']['trade']
        client = self.authenticate(url)
        subscriptionHashes = list(client.subscriptions.keys())
        for i in range(0, len(subscriptionHashes)):
            subscriptionHash = subscriptionHashes[i]
            if subscriptionHash.find('NEW_TRADE_BUCKET') >= 0:
                subMarketId = self.safe_string(subscriptionHash.split(':'), 1)
                if subMarketId and not self.in_array(subMarketId, marketIds):
                    marketIds.append(subMarketId)
        message = {
            'type': 'SUBSCRIBE',
            'subscriptions': [
                {
                    'event': 'NEW_TRADE_BUCKET',
                    'pairs': marketIds,
                },
            ],
        }
        # call to watchMultiple only gets one of the multiple symbolsAndTimeframes returned all arrive
        # at the same time. The rest are stored in seperate caches.
        symbolWs, timeframeWs, candles = await self.watch_multiple(url, messageHashes, message, messageHashes)
        # symbolTimeframeCandles = {}
        if self.newUpdates:
            # for i in range(0, len(symbols)):
            #     symbolReq = symbols[i]
            #     candleSymbol = self.safe_dict(self.ohlcvs, symbolReq)
            #     if candleSymbol is not None:
            #         candleStored = self.safe_value(candleSymbol, timeframeWs)
            #         if candleStored is not None:
            #             limitReg = candles.getLimit(symbolWs, limit)
            #             filtered = self.filter_by_since_limit(candles, since, limit, 0, True)
            #             symbolTimeframeCandles[symbolReq] = {}
            #             symbolTimeframeCandles[symbolReq][timeframeWs] = filtered
            #         }
            #     }
            # }
            limit = candles.getLimit(symbolWs, limit)
        filtered = self.filter_by_since_limit(candles, since, limit, 0, True)
        return self.create_ohlcv_object(symbolWs, timeframeWs, filtered)

    def handle_ohlcv(self, client: Client, message):
        # Only support timeframe of 1m
        # {
        #     type: 'NEW_TRADE_BUCKET',
        #     currencyPairSymbol: 'BTCUSDC',
        #     data: {
        #       currencyPairSymbol: 'BTCUSDC',
        #       bucketPeriodInSeconds: 60,
        #       startTime: '2024-04-05T09:03:00Z',
        #       open: '67310',
        #       high: '67310',
        #       low: '67310',
        #       close: '67310',
        #       volume: '0',
        #       quoteVolume: '0'
        #     }
        # }
        updateType = self.safe_string(message, 'type')
        marketId = self.safe_string(message, 'currencyPairSymbol')
        symbol = self.safe_symbol(marketId)
        data = self.safe_value(message, 'data')
        period = self.safe_integer(data, 'bucketPeriodInSeconds')
        timeframe = self.find_timeframe(period)
        parsed = [
            self.parse8601(self.safe_string(data, 'startTime')),
            self.safe_number(data, 'open'),  # open
            self.safe_number(data, 'high'),  # high
            self.safe_number(data, 'low'),  # low
            self.safe_number(data, 'close'),  # close
            self.safe_number(data, 'volume'),  # volume
        ]
        self.ohlcvs[symbol] = self.safe_value(self.ohlcvs, symbol, {})
        stored = self.safe_value(self.ohlcvs[symbol], timeframe)
        if stored is None:
            limit = self.safe_integer(self.options, 'OHLCVLimit', 1000)
            stored = ArrayCacheByTimestamp(limit)
            self.ohlcvs[symbol][timeframe] = stored
        stored.append(parsed)
        # for multiOHLCV we need special object, to other "multi"
        # methods, because OHLCV response item does not contain symbol
        # or timeframe, thus otherwise it would be unrecognizable
        messageHash = updateType + '_' + timeframe + ':' + marketId
        client.resolve([symbol, timeframe, stored], messageHash)
        # if self.verbose:
        #     self.log(self.iso8601(self.milliseconds()), 'handleOHLCV', symbol, timeframe, parsed)
        # }

    async def watch_balance(self, params={}) -> Balances:
        await self.load_markets()
        url = self.urls['api']['ws']['account']
        messageHash = 'BALANCE_UPDATE'
        self.authenticate(url)
        balances = await self.watch(url, messageHash)
        return balances

    def handle_balance(self, client: Client, message):
        data = self.safe_value(message, 'data')
        # {
        #     "type": "BALANCE_UPDATE",
        #     "data":
        #     {
        #         "currency":
        #         {
        #             "symbol": "R",
        #             "decimalPlaces": 2,
        #             "isActive": "True",
        #             "shortName": "ZAR",
        #             "longName": "Rand",
        #             "supportedWithdrawDecimalPlaces": 2,
        #             "collateral": "True",
        #             "collateralWeight": "0.99"
        #         },
        #         "available": "1022.05",
        #         "reserved": "10",
        #         "total": "1032.05",
        #         "updatedAt": "2024-03-25T15:38:48.580Z",
        #         "lendReserved": "0",
        #         "borrowCollateralReserved": "0",
        #         "borrowedAmount": "0",
        #         "totalInReference": "53.31359999",
        #         "totalInReferenceWeighted": "52.7804639901",
        #         "referenceCurrency": "USDC"
        #     }
        # }
        code, balance = self.parse_ws_balance(data)
        if self.balance is None:
            self.balance = {}
        self.balance['info'] = self.safe_value(balance, 'info')
        self.balance['datetime'] = self.safe_string(balance, 'datetime')
        self.balance['timestamp'] = self.safe_string(balance, 'timestamp')
        if code is not None:
            self.balance[code] = self.safe_dict(balance, code)
            self.balance = self.safe_balance(self.balance)
        updateType = self.safe_string(message, 'type')
        client.resolve(balance, updateType)
        # if self.verbose:
        #     self.log(self.iso8601(self.milliseconds()), 'handleBalance', balance)
        # }

    def parse_ws_balance(self, balanceWs) -> Any:
        result = {
            'timestamp': self.parse8601(self.safe_string(balanceWs, 'updatedAt')),
            'datetime': self.safe_string(balanceWs, 'updatedAt'),
            'info': balanceWs,
        }
        currency = self.safe_value(balanceWs, 'currency')
        code = self.safe_currency_code(self.safe_string(currency, 'shortName'))
        debt = Precise.string_add(
            self.safe_string(balanceWs, 'lendReserved'),
            self.safe_string(balanceWs, 'borrowReserved')
        )
        if code is not None:
            result[code] = {
                'free': self.safe_float(balanceWs, 'available'),
                'used': self.safe_float(balanceWs, 'reserved'),
                'total': self.safe_float(balanceWs, 'total'),
                'debt': debt,
            }
        return [code, result]

    async def watch_my_trades(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}) -> List[Trade]:
        await self.load_markets()
        url = self.urls['api']['ws']['account']
        messageHash = 'NEW_ACCOUNT_TRADE'
        if symbol:
            messageHash = messageHash + ':' + symbol
        self.authenticate(url)
        trades = await self.watch(url, messageHash)
        if self.newUpdates:
            limit = trades.getLimit(symbol, limit)
        return self.filter_by_symbol_since_limit(trades, symbol, since, limit, True)

    def handle_my_trades(self, client: Client, message):
        # {
        #     "type": "NEW_ACCOUNT_TRADE",
        #     "currencyPairSymbol": "BTCZAR",
        #     "data": {
        #       "price": "9500",
        #       "quantity": "0.00105263",
        #       "currencyPair": "BTCZAR",
        #       "tradedAt": "2019-04-25T20:36:53.426Z",
        #       "side": "buy",
        #       "orderId":"d5a81b99-fabf-4be1-bc7c-1a00d476089d",
        #       "id":"7a2b5560-5a71-4640-9e4b-d659ed26278a"
        #     }
        #   }
        marketId = self.safe_string(message, 'currencyPairSymbol')
        symbol = self.safe_symbol(marketId)
        tradeMessage = self.safe_dict(message, 'data')
        timestamp = self.parse8601(self.safe_string(tradeMessage, 'tradedAt'))
        myTrade = self.safe_trade({
            'info': tradeMessage,
            'timestamp': timestamp,
            'datetime': self.safe_string(tradeMessage, 'tradedAt'),
            'id': self.safe_string(tradeMessage, 'id'),
            'order': self.safe_string(tradeMessage, 'orderId'),
            'symbol': symbol,
            'side': self.safe_string(tradeMessage, 'side'),
            'amount': self.safe_number(tradeMessage, 'quantity'),
            'price': self.safe_number(tradeMessage, 'price'),
        })
        # watch All symbols
        cachedTrades = self.myTrades
        if cachedTrades is None:
            limit = self.safe_integer(self.options, 'tradesLimit', 1000)
            cachedTrades = ArrayCacheBySymbolById(limit)
            self.myTrades = cachedTrades
        updateType = self.safe_string(message, 'type')
        messageHashSymbol = updateType + ':' + symbol
        cachedTrades.append(myTrade)
        client.resolve(cachedTrades, updateType)
        # watch specific symbol
        client.resolve(cachedTrades, messageHashSymbol)
        # if self.verbose:
        #     self.log(self.iso8601(self.milliseconds()), 'handleMyTrades', myTrade)
        # }

    async def watch_orders(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}) -> List[Order]:
        await self.load_markets()
        url = self.urls['api']['ws']['account']
        messageHashes = [
            # 'INSTANT_ORDER_COMPLETED',  # New Simple Buy/Sell executed
            # New order added to open orders
            'OPEN_ORDERS_UPDATE',
            'ORDER_STATUS_UPDATE',
            # {
            #     "type": "ORDER_STATUS_UPDATE",
            #     "data":
            #     {
            #         "orderId": "0967a400-fcb3-45bd-8f4a-e2b0872f53a8",
            #         "orderStatusType": "Cancelled",
            #         "currencyPair": "BTCZAR",
            #         "originalPrice": "2000000",
            #         "remainingQuantity": "0.00001",
            #         "originalQuantity": "0.00001",
            #         "orderSide": "sell",
            #         "orderType": "post-only limit",
            #         "failedReason": "",
            #         "orderUpdatedAt": "2024-04-01T16:01:41.456Z",
            #         "orderCreatedAt": "2024-04-01T16:00:31.074Z",
            #         "executedPrice": "0",
            #         "executedQuantity": "0",
            #         "executedFee": "0"
            #     }
            # }
        ]
        self.authenticate(url)
        if symbol:
            for i in range(0, len(messageHashes)):
                messageHashes[i] = messageHashes[i] + ':' + symbol
        orders = await self.watch_multiple(url, messageHashes)
        if self.newUpdates:
            limit = orders.getLimit(symbol, limit)
        return self.filter_by_symbol_since_limit(orders, symbol, since, limit)

    def handle_orders(self, client: Client, message):
        # if self.verbose:
        #     self.log(self.iso8601(self.milliseconds()), 'handleOrders', message)
        # }
        messageHash = self.safe_string(message, 'type')
        data = self.safe_value(message, 'data')
        results = []
        messageHashesSymbol = []
        ordersMessage = []
        if isinstance(data, list):
            ordersMessage = self.array_concat(ordersMessage, data)
        else:
            ordersMessage.append(data)
        for i in range(0, len(ordersMessage)):
            orderWs = self.parse_ws_order(ordersMessage[i])
            results.append(orderWs)
            symbol = self.safe_string(orderWs, 'symbol')
            # orderId = self.safe_string(parsed, 'id')
            if symbol is not None:
                messageHashSymbol = messageHash + ':' + symbol
                if not self.in_array(messageHashesSymbol, messageHashesSymbol):
                    messageHashesSymbol.append(messageHashSymbol)
                if self.orders is None:
                    limit = self.safe_integer(self.options, 'ordersLimit', 1000)
                    self.orders = ArrayCacheBySymbolById(limit)
                cachedOrders = self.orders
                # orders = self.safe_value(cachedOrders.hashmap, symbol, {})
                # order = self.safe_value(orders, orderId)
                # if order is not None:
                # Use data from existing order before updating orders
                # }
                cachedOrders.append(orderWs)
        client.resolve(self.orders, messageHash)
        for i in range(0, len(messageHashesSymbol)):
            client.resolve(self.orders, messageHashesSymbol[i])

    def parse_ws_order(self, order, market=None):
        # OPEN_ORDERS_UPDATE : New order added to open orders
        # [
        #     {
        #         "orderId": "38511e49-a755-4f8f-a2b1-232bae6967dc",
        #         "side": "sell",
        #         "quantity": "0.1",
        #         "price": "10000",
        #         "currencyPair": "BTCZAR"
        #         "createdAt": "2019-04-17T19:51:35.776Z",
        #         "originalQuantity": "0.1",
        #         "filledPercentage": "0.00",
        #         "type": "post-only limit",
        #         "status": "placed",
        #         "updatedAt": "2019-04-17T19:51:35.776Z",
        #         "timeInForce": "GTC",
        #         "customerOrderId": ""
        #     },
        #     {
        #         "orderId": "3f759a40-09ee-44bd-a5aa-29836bbaab1a",
        #         "side": "sell",
        #         "quantity": "0.04",
        #         "price": "10000",
        #         "currencyPair": "BTCZAR"
        #         "createdAt": "2019-04-17T19:51:35.776Z",
        #         "originalQuantity": "0.1",
        #         "filledPercentage": "60.00",
        #         "customerOrderId": "3"
        #         "type": "post-only limit",
        #         "status": "placed",
        #         "updatedAt": "2019-04-17T19:51:35.776Z",
        #         "timeInForce": "GTC",
        #     },
        # ]
        # OPEN_ORDERS_UPDATE : Open order modified
        # [
        #     {
        #         "orderId":"6eaf85b7-7e69-4e26-9664-33a8f23bfb4f",
        #         "side":"buy",
        #         "quantity":"0.0002",
        #         "price":"29300",
        #         "currencyPair":"BTCUSDC",
        #         "createdAt":"2023-10-24T13:33:43.503Z",
        #         "originalQuantity":"0.0002",
        #         "filledPercentage":"0.00",
        #         "customerOrderId":"MyLimit1234",
        #         "type":"limit",
        #         "status":"Order Modified",
        #         "updatedAt":"2023-10-24T13:36:42.660Z",
        #         "timeInForce":"GTC"
        #     },
        # ]
        # ORDER_STATUS_UPDATE : Order status has been updated
        # {
        #     "orderId": "9135e74e-bd4f-4aec-ba1f-d38897826cda",
        #     "orderStatusType": "Cancelled",
        #     "currencyPair": "BTCZAR",
        #     "originalPrice": "2100000",
        #     "remainingQuantity": "0.00002",
        #     "originalQuantity": "0.00002",
        #     "orderSide": "sell",
        #     "orderType": "post-only limit",
        #     "failedReason": "None",
        #     "orderUpdatedAt": "2024-04-01T16:14:00.963Z",
        #     "orderCreatedAt": "2024-04-01T16:01:55.985Z",
        #     "executedPrice": "0",
        #     "executedQuantity": "0",
        #     "executedFee": "0"
        # }
        # {
        #     "orderId": "bf17d427-f9e8-44ef-82c1-4ed94c5f4f7f",
        #     "orderStatusType": "Filled",
        #     "currencyPair": "BTCZAR",
        #     "originalPrice": "1335001",
        #     "remainingQuantity": "0",
        #     "originalQuantity": "0.00001",
        #     "orderSide": "sell",
        #     "orderType": "post-only limit",
        #     "failedReason": "",
        #     "orderUpdatedAt": "2024-04-01T16:14:54.716Z",
        #     "orderCreatedAt": "2024-04-01T16:13:53.400Z",
        #     "executedPrice": "1335001",
        #     "executedQuantity": "0.00001",
        #     "executedFee": "0"
        # }
        orderStatus = self.safe_string_2(order, 'status', 'orderStatusType')
        status = None
        if orderStatus == 'Placed' or orderStatus == 'Order Modified':
            status = 'open'
        elif orderStatus == 'Cancelled' or orderStatus == 'Failed':
            status = 'canceled'
        elif orderStatus == 'Filled':
            status = 'closed'
        orderTypeReceived = self.safe_string(order, 'type')
        typeOrder = None
        postOnly = None
        if orderTypeReceived is not None:
            if self.in_array('limit', orderTypeReceived):
                typeOrder = 'limit'
                if self.in_array('post-only', orderTypeReceived):
                    postOnly = True
                else:
                    postOnly = False
        filledPercentage = self.safe_string(order, 'filledPercentage')
        remaining = self.safe_string(order, 'remainingQuantity')
        amount = self.safe_string(order, 'originalQuantity')
        filled = None
        if remaining is None and filledPercentage is not None:
            filled = Precise.string_mul(amount, filledPercentage)
        return self.safe_order({
            'timestamp': self.parse8601(self.safe_string_2(order, 'createdAt', 'orderCreatedAt')),
            'datetime': self.safe_string_2(order, 'createdAt', 'orderCreatedAt'),
            'id': self.safe_string(order, 'orderId'),
            'clientOrderId': self.safe_string(order, 'customerOrderId'),
            'symbol': self.safe_symbol(self.safe_string(order, 'currencyPair')),
            'status': status,
            'type': typeOrder,
            'side': self.safe_string_2(order, 'side', 'orderSide'),
            'price': self.safe_string_2(order, 'price', 'originalPrice'),
            'amount': amount,
            'average': self.safe_string(order, 'averagePrice'),
            'filled': filled,
            'remaining': remaining,
            'lastUpdateTimestamp': self.parse8601(self.safe_string_2(order, 'updatedAt', 'orderUpdatedAt')),
            'timeInForce': self.safe_string(order, 'timeInForce'),
            'postOnly': postOnly,
            'info': order,
        })

    async def watch_transactions(self, code: Str = None, since: Int = None, limit: Int = None, params={}):
        await self.load_markets()
        url = self.urls['api']['ws']['account']
        messageHashes = [
            'ORDER_PROCESSED',
            # {
            #     "type": "ORDER_PROCESSED",
            #     "data": {
            #       "orderId": "247dc157-bb5b-49af-b476-2f613b780697",
            #       "success": True,
            #       "failureReason": ""
            #     }
            # }
            'MODIFY_ORDER_OUTCOME',  # Order modified
            # {
            #     "type": "MODIFY_ORDER_OUTCOME",
            #     "data": {
            #       "success":true,
            #       "orderId":"6eaf85b7-7e69-4e26-9664-33a8f23bfb4f",
            #       "customerOrderId":"MyLimit1234",
            #       "modifyRequestId":"e0632f4e-7dab-11ee-95c0-07ba663465ab"
            #     }
            # }
            'FAILED_CANCEL_ORDER',
            # {
            #     "type": "FAILED_CANCEL_ORDER",
            #     "data": {
            #         "orderId": "247dc157-bb5b-49af-b476-2f613b780697",
            #         "message": "An error occurred while cancelling your order."
            #     }
            # }
        ]
        self.authenticate(url)
        result = await self.watch_multiple(url, messageHashes)
        return result

    def handle_transaction(self, client: Client, message):
        messageHash = self.safe_string(message, 'type')
        results = []
        results.append(message)
        client.resolve(results, messageHash)
        # if self.verbose:
        #     self.log(self.iso8601(self.milliseconds()), 'handleTransaction', results)
        # }

    def ping(self, client: Client):
        return {'type': 'PING'}

    def handle_pong(self, client: Client, message):
        client.lastPong = self.milliseconds()
        # {'type': 'PONG'}
        # if self.verbose:
        #     self.log(self.iso8601(client.lastPong), 'handlePong', client.url, message)
        # }
        return message

    def handle_message(self, client: Client, message):
        if message == '':
            # self.log(self.iso8601(self.milliseconds()), 'Empty Message')
            return
        methods = {
            'AGGREGATED_ORDERBOOK_UPDATE': self.handle_order_book,
            # 'FULL_ORDERBOOK_UPDATE': self.log,
            # {"type":"FULL_ORDERBOOK_UPDATE","currencyPairSymbol":"PYUSDUSDT","data":{"LastChange":1711543154427,"Asks":[{"Price":"0.99732","Orders":[{"orderId":"041200ae-2849-4660-93bd-ff6b8d1ebd39","quantity":"0"}]},{"Price":"0.99766","Orders":[{"orderId":"b6c577f1-bf4d-4963-9e9e-aa87499ee93c","quantity":"0"}]},{"Price":"0.99816","Orders":[{"orderId":"3d9ed086-0079-4cda-b052-5fbbf5fd6966","quantity":"0"}]},{"Price":"1.00315","Orders":[{"orderId":"992b1ba2-0a58-404f-9710-2fa617a908fe","quantity":"0"}]},{"Price":"1.00817","Orders":[{"orderId":"f0b97400-f7ed-43f1-be48-6097e71e5a25","quantity":"0"}]},{"Price":"1.01321","Orders":[{"orderId":"82555657-3968-42e7-b4d2-b9866b2e59aa","quantity":"0"}]}],"Bids":[{"Price":"0.99726","Orders":[{"orderId":"cb1a92fa-0db4-42db-bca8-0fee32cdfc8d","quantity":"0"}]},{"Price":"0.99678","Orders":[{"orderId":"8d4a8efd-f871-40d6-8c63-576d20e7777c","quantity":"0"}]},{"Price":"0.99628","Orders":[{"orderId":"517a2a39-dfe9-4605-938b-4564313012a4","quantity":"0"}]},{"Price":"0.99129","Orders":[{"orderId":"e4851eeb-25d4-4383-891c-7361c3e1bb10","quantity":"0"}]},{"Price":"0.98633","Orders":[{"orderId":"6a45081f-37e3-4977-9e91-68a95505698f","quantity":"0"}]},{"Price":"0.98139","Orders":[{"orderId":"6837f9fb-f4fc-434a-914b-0e25e9d1585a","quantity":"0"}]}],"SequenceNumber":173335,"Checksum":492550141}}
            'MARKET_SUMMARY_UPDATE': self.handle_ticker,
            'NEW_TRADE_BUCKET': self.handle_ohlcv,
            'NEW_TRADE': self.handle_trades,
            # 'MARK_PRICE_UPDATE': self.log,
            # Used for instant buy/sell orders not for exchange.
            # {"type":"MARK_PRICE_UPDATE","currencyPairSymbol":"BTCZAR","data":{"price":"1360201"}}
            'PONG': self.handle_pong,
            'BALANCE_UPDATE': self.handle_balance,
            'NEW_ACCOUNT_TRADE': self.handle_my_trades,
            'OPEN_ORDERS_UPDATE': self.handle_orders,
            'ORDER_STATUS_UPDATE': self.handle_orders,
            'ORDER_PROCESSED': self.handle_transaction,
            'MODIFY_ORDER_OUTCOME': self.handle_transaction,
            'FAILED_CANCEL_ORDER': self.handle_transaction,
        }
        eventType = self.safe_string(message, 'type')
        method = self.safe_value(methods, eventType)
        # subscriptions = list(client.subscriptions.values())
        # messageHash = list(client.messageHash.values())
        if method:
            # if client.verbose:
            #     self.log(self.iso8601(self.milliseconds()), 'handleMessage', 'eventType:', eventType, 'method:', method)
            # }
            method(client, message)
        # else:
        #     if self.verbose:
        #         self.log(self.iso8601(self.milliseconds()), 'handleMessage: Unknown message.', message)
        #     }

    def authenticate(self, url: str) -> Client:
        if (self.clients is not None) and (url in self.clients):
            return self.client(url)
        self.check_required_credentials()
        timestamp = str(self.milliseconds())
        urlParts = url.split('/')
        partsLength = len(urlParts)
        path = '/' + self.safe_string(urlParts, partsLength - 2) + '/' + self.safe_string(urlParts, partsLength - 1)
        message = timestamp + 'GET' + path
        payloadBase64 = self.string_to_base64(message)
        signature = self.hmac(
            self.base64_to_binary(payloadBase64),
            self.base64_to_binary(self.string_to_base64(self.secret)),
            'sha512',
            'hex'
        )
        # Can't pass headers directly to self.client. Use self.options['ws'] instead.
        defaultOptions = {
            'ws': {
                'options': {
                    'headers': {},
                },
            },
        }
        self.extend_exchange_options(defaultOptions)
        originalHeaders = self.options['ws']['options']['headers']
        headers = {
            'X-VALR-API-KEY': self.apiKey,
            'X-VALR-SIGNATURE': signature,
            'X-VALR-TIMESTAMP': timestamp,
        }
        self.options['ws']['options']['headers'] = headers
        client = self.client(url)
        self.options['ws']['options']['headers'] = originalHeaders
        return client
