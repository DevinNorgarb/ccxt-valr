# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.exchange import Exchange
from ccxt.abstract.valr import ImplicitAPI
from ccxt.base.types import Account, Balances, Currencies, Currency, Int, Market, Order, OrderBook, OrderRequest, OrderSide, OrderType, Ticker, Tickers, Trade, TradingFees, Transaction
from typing import List
from typing import Any
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import BadRequest
from ccxt.base.errors import BadSymbol
from ccxt.base.errors import NullResponse
from ccxt.base.errors import InvalidOrder
from ccxt.base.errors import NotSupported
from ccxt.base.precise import Precise


class valr(Exchange, ImplicitAPI):

    def describe(self):
        return self.deep_extend(super(valr, self).describe(), {
            'id': 'valr',
            'name': 'VALR',
            'countries': ['ZA'],
            'rateLimit': 1000,
            'version': '1',
            # 'comment': 'This comment is optional',
            'has': {
                'CORS': None,
                'spot': True,
                'margin': None,
                'swap': None,
                'future': None,
                'option': None,
                'cancelAllOrders': True,
                'cancelOrder': True,
                'createMarketBuyOrderWithCost': True,
                'createMarketSellOrderWithCost': True,
                'createOrder': True,
                'createPostOnlyOrder': True,
                'fetchAccounts': True,
                'fetchBalance': True,
                'fetchClosedOrders': True,
                'fetchCurrencies': True,
                'fetchDepositAddress': True,
                'fetchDeposits': True,
                'fetchFundingLimits': False,
                'fetchL3OrderBook': True,
                'fetchLedger': False,
                'fetchMyTrades': True,
                'fetchOHLCV': False,
                'fetchOpenOrders': True,
                'fetchOrder': True,
                'fetchOrderBook': True,
                'fetchOrderBooks': False,
                'fetchOrders': False,
                'fetchPermissions': True,
                'fetchStatus': True,
                'fetchTicker': True,
                'fetchTickers': True,
                'fetchTime': True,
                'fetchTrades': True,
                'fetchTradingFees': True,
                'fetchTransactions': False,
                'fetchWithdrawals': True,
                'transfer': False,
                'withdraw': True,
            },
            'urls': {
                'logo': None,
                'api': {
                    'public': 'https://api.valr.com/v1/public',
                    'private': 'https://api.valr.com/v1',
                },
                'www': 'https://www.valr.com',
                'doc': [
                    'https://docs.valr.com/',
                ],
                'fees': 'https://support.valr.com/hc/en-us/articles/360015777451-What-are-VALR-s-charges',
                'referral': {
                    'url': 'https://www.valr.com/invite/VAE2R2GV',
                },
            },
            'requiredCredentials': {
                'apiKey': True,
                'secret': True,
            },
            'api': {
                'public': {
                    'get': [
                        '{pair}/orderbook',
                        '{pair}/orderbook/full',
                        'currencies',
                        'pairs',
                        'ordertypes',
                        '{pair}/ordertypes',
                        'marketsummary',
                        '{pair}/marketsummary',
                        '{pair}/markprice/buckets',
                        '{pair}/trades',
                        '{pair}/futures/funding/history',
                        'time',
                        'status',
                        'futures/info',
                    ],
                },
                'private': {
                    'get': [
                        'account/api-keys/current',
                        'account/subaccounts',
                        'account/balances',
                        'account/balances/all',
                        'account/transactionhistory',
                        'account/{pair}/tradehistory',
                        'account/fees/trade',
                        'marketdata/{pair}/orderbook',
                        'marketdata/{pair}/orderbook/full',
                        'marketdata/{pair}/tradehistory',
                        'wallet/crypto/{currency}/deposit/address',
                        'wallet/crypto/{currency}/deposit/history',
                        'wallet/crypto/address-book',
                        'wallet/crypto/address-book/{currency}',
                        'wallet/crypto/{currency}/withdraw',
                        'wallet/crypto/{currency}/withdraw/{id}',
                        'wallet/crypto/{currency}/withdraw/history',
                        'wallet/fiat/{currency}/accounts/{id}',
                        'wallet/fiat/{currency}/accounts',
                        'wallet/fiat/{currency}/banks',
                        'wallet/fiat/{currency}/deposit/reference',
                        'wallet/fiat/{currency}/deposit/reference/{currency}',
                        'wallet/fiat/{currency}/auto-buy',
                        'wire/accounts',
                        'simple/{pair}/order/{id}',
                        'pay/limits',
                        'pay/payid',
                        'pay/history',
                        'pay/identifier/{identifier}',
                        'pay/transactionid/{id}',
                        'orders/{pair}/orderid/{id}',
                        'orders/{pair}/customerorderid/{id}',
                        'orders/open',
                        'orders/history',
                        'orders/history/summary/orderid/{id}',
                        'orders/history/summary/customerorderid/{id}',
                        'orders/history/detail/orderid/{id}',
                        'orders/history/detail/customerorderid/{id}',
                        'staking/balances/{currency}',
                        'staking/rates',
                        'staking/rates/{currency}',
                        'staking/rewards',
                        'staking/history',
                        'margin/status',
                        'margin/account/status',
                        'positions/open',
                        'positions/closed/summary',
                        'positions/closed',
                        'positions/history',
                        'positions/funding/history',
                        'borrows/{currency}/history',
                        'loans/rates',
                    ],
                    'post': [
                        'account/subaccount',
                        'account/subaccounts/transfer',
                        'wallet/crypto/{currency}/withdraw',
                        'wallet/fiat/{currency}/accounts',
                        'wallet/fiat/{currency}/withdraw',
                        'wire/withdrawals',
                        'simple/{pair}/quote',
                        'simple/{pair}/order',
                        'pay',
                        'orders/limit',
                        'orders/market',
                        'orders/stop/limit',
                        'batch/orders',
                        'staking/stake',
                        'staking/un-stake',
                    ],
                    'put': [
                        'pay/transactionid/{id}/reverse',
                        'orders/modify',
                        'margin/account/status',
                    ],
                    'delete': [
                        'wallet/fiat/{currency}/accounts/{id}',
                        'orders/order',
                        'orders',
                        'orders/{pair}',
                    ],
                },
                'privateV2': {
                    'get': [
                        'margin/status',
                        'healthz',
                    ],
                    'post': [
                        'orders/market',
                        'orders/limit',
                        'orders/stop/limit',
                    ],
                    'put': [
                        'orders/modify',
                    ],
                    'delete': [
                        'orders/order',
                    ],
                },
            },
            'headers': {
                'Content-Type': 'application/json',
            },
            'fees': {
                'trading': {
                    'percentage': True,
                    'maker': self.parse_number('-0.0001'),
                    'taker': self.parse_number('0.003'),
                },
            },
            'options': {
                'fiat': {
                    'ZAR': 'ZAR',
                    'USD': 'USD',
                },
                'tradingFeesByPairType': {
                    'ZAR': 0.001,
                    'PERP': 0.0005,
                },
            },
        })

    def check_required_symbol_argument(self, methodName: str, symbol: str):
        if symbol is None:
            raise ArgumentsRequired(self.id + ' ' + methodName + '() requires valid symbol name')
        if not isinstance(symbol, str):
            raise ArgumentsRequired(self.id + ' ' + methodName + '() requires valid string name for symbol')
        market = self.safe_market(symbol)
        if market is None:
            raise BadSymbol(self.id + ' ' + methodName + '() found no valid market for symbol: ' + symbol)

    def check_required_currency_code_argument(self, methodName: str, code: str):
        if code is None:
            raise ArgumentsRequired(self.id + ' ' + methodName + '() requires valid currency code name')
        currency = self.safe_currency(code)
        if currency['id'] is None:
            raise BadRequest(self.id + ' ' + methodName + '() found no valid currency ID for currency code: ' + code)

    def is_fiat(self, code):
        return(code in self.options['fiat'])

    def fetch_time(self, params={}) -> float:
        """
        fetches the current integer timestamp in milliseconds from the exchange server
        :see: https://docs.valr.com/#95f84056-2ac7-4f92-a5d9-fd0d9c104f01
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns int: the current integer timestamp in milliseconds from the exchange server
        """
        response = self.publicGetTime(params)
        return self.parse8601(self.safe_string(response, 'time'))

    def fetch_status(self, params={}) -> Any:
        """
        :see: https://docs.valr.com/#88ab52a2-d63b-48b2-8984-d0982baec40a
        fetch status of exchange
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: A `exchange status structure <https://docs.ccxt.com/#/?id=exchange-status-structure>`
        """
        response = self.publicGetStatus(params)
        statusReport = self.safe_string(response, 'status')
        status = None
        if statusReport == 'online':
            status = 'ok'
        elif statusReport == 'read-only':
            status = 'maintenance'
        return {
            'status': status,
            'updated': None,
            'eta': None,
            'url': 'https://status.valr.com/',
            'info': response,
        }

    def fetch_currencies(self, params={}) -> Currencies:
        """
        :see: https://docs.valr.com/#88ab52a2-d63b-48b2-8984-d0982baec40a
        fetches all available currencies on an exchange
         * @param {{}} [params={}] extra parameters specific to the exchange API endpoint
        :returns dict: an associative dictionary of `Currency Structure <https://docs.ccxt.com/#/?id=currency-structure>`
        """
        currencies = self.publicGetCurrencies(params)
        # [
        #     {
        #       "symbol": "R",
        #       "isActive": True,
        #       "shortName": "ZAR",
        #       "longName": "Rand",
        #       "decimalPlaces": "2",
        #       "withdrawalDecimalPlaces": "2",
        #       "collateral": True,
        #       "collateralWeight": "1"
        #     },
        #     {
        #       "symbol": "BTC",
        #       "isActive": True,
        #       "shortName": "BTC",
        #       "longName": "Bitcoin",
        #       "decimalPlaces": "8",
        #       "withdrawalDecimalPlaces": "8",
        #       "collateral": True,
        #       "collateralWeight": "0.95",
        #       "defaultNetworkType": "Bitcoin",
        #       "supportedNetworks": [
        #         {
        #           "networkType": "Bitcoin",
        #           "networkLongName": "Bitcoin"
        #         }
        #       ]
        #     },
        #     {
        #       "symbol": "ETH",
        #       "isActive": True,
        #       "shortName": "ETH",
        #       "longName": "Ethereum",
        #       "decimalPlaces": "18",
        #       "withdrawalDecimalPlaces": "8",
        #       "collateral": True,
        #       "collateralWeight": "0.95",
        #       "defaultNetworkType": "Ethereum",
        #       "supportedNetworks": [
        #         {
        #           "networkType": "Ethereum",
        #           "networkLongName": "Ethereum"
        #         }
        #       ]
        #     },
        #     ...
        # ]
        result = {}
        for i in range(0, len(currencies)):
            currency = currencies[i]
            code = self.safe_currency_code(self.safe_string(currency, 'shortName'))
            precision = self.safe_integer(currency, 'decimalPlaces')
            # Siacoin reports precision of 24 which does not pass build test
            if (precision is not None) and (precision > 18):
                precision = 18
            result[code] = self.safe_currency_structure({
                'id': self.safe_string(currency, 'shortName'),
                'code': code,
                'info': currency,
                'name': self.safe_string(currency, 'longName'),
                'active': self.safe_string(currency, 'isActive'),
                'precision': precision,
                'withdraw': True if ('supportedNetworks' in currency) else False,
                'deposit': True if ('supportedNetworks' in currency) else False,
            })
        return result

    def fetch_markets(self, params={}):
        """
        retrieves data on all markets for valr
        :see: https://docs.valr.com/#cfa57d7e-2106-4066-bc27-c10210b6aa82
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a list of `Market Structure <https://docs.ccxt.com/#/?id=market-structure>`
        """
        markets = self.publicGetPairs(params)
        # [
        #     {'symbol': 'ENJUSDC',
        #     'baseCurrency': 'ENJ',
        #     'quoteCurrency': 'USDC',
        #     'shortName': 'ENJ/USDC',
        #     'active': True,
        #     'minBaseAmount': '3.5',
        #     'maxBaseAmount': '3586.3',
        #     'minQuoteAmount': '2',
        #     'maxQuoteAmount': '5000',
        #     'tickSize': '0.01',
        #     'baseDecimalPlaces': '2',
        #     'marginTradingAllowed': False,
        #     'currencyPairType': 'SPOT'},
        #    {'symbol': 'USDTZARPERP',
        #     'baseCurrency': 'USDT',
        #     'quoteCurrency': 'ZAR',
        #     'shortName': 'USDT/ZARPERP',
        #     'active': True,
        #     'minBaseAmount': '1',
        #     'maxBaseAmount': '250000',
        #     'minQuoteAmount': '15',
        #     'maxQuoteAmount': '5000000',
        #     'tickSize': '0.01',
        #     'baseDecimalPlaces': '3',
        #     'marginTradingAllowed': False,
        #     'currencyPairType': 'FUTURE'
        # },
        # ]
        return self.parse_markets(markets)

    def parse_market(self, market) -> Market:
        base = self.safe_currency_code(self.safe_string(market, 'baseCurrency'))
        quote = self.safe_currency_code(self.safe_string(market, 'quoteCurrency'))
        currencyPairType = self.safe_string(market, 'currencyPairType')
        marketType = None
        spot = None
        swap = None
        symbol = base + '/' + quote
        # required for future contracts
        contract = False
        linear = None
        contractSize = None
        settle = None
        settleId = None
        taker = self.safe_number(self.options['tradingFeesByPairType'], quote, self.fees['trading']['taker'])
        if currencyPairType == 'SPOT':
            marketType = 'spot'
            spot = True
        elif currencyPairType == 'FUTURE':
            taker = self.safe_number(self.options['tradingFeesByPairType'], 'PERP', self.fees['trading']['taker'])
            marketType = 'swap'
            spot = False
            swap = True
            symbol = symbol + ':' + quote
            contract = True
            # Guess value
            contractSize = self.parse_number('1')
            # According to docs: https://support.valr.com/hc/en-us/articles/11078306427420-Perpetual-Futures-Trading-Guide
            linear = True
            settle = base
            settleId = self.safe_string(market, 'baseCurrency')
            symbol = base + '/' + quote + ':' + settle
        return self.safe_market_structure({
            'id': self.safe_string(market, 'symbol'),
            'symbol': symbol,
            'base': base,
            'quote': quote,
            'baseId': self.safe_string(market, 'baseCurrency'),
            'quoteId': self.safe_string(market, 'quoteCurrency'),
            'active': self.safe_bool(market, 'active'),
            'type': marketType,
            'spot': spot,
            'margin': self.safe_bool(market, 'marginTradingAllowed'),
            'future': False,
            'swap': swap,
            'option': False,
            'contract': contract,
            'percentage': True,
            'tierBased': False,
            'linear': linear,
            'contractSize': contractSize,
            'settle': settle,
            'settleId': settleId,
            # Setting defaults based on exchange not on response
            # These values are actually from private API call and can be overwriten with loadTradingFees
            'taker': taker,
            'maker': self.parse_number(self.fees['trading']['maker']),
            'precision': {
                'price': self.precision_from_string(self.safe_string(market, 'tickSize')),
                'amount': self.safe_integer(market, 'baseDecimalPlaces'),
            },
            'limits': {
                'amount': {
                    'min': self.safe_float(market, 'minBaseAmount'),
                    'max': self.safe_float(market, 'maxBaseAmount'),
                },
                'price': {
                    'min': self.safe_float(market, 'minQuoteAmount'),
                    'max': self.safe_float(market, 'maxQuoteAmount'),
                },
            },
            'info': market,
        })

    def fetch_tickers(self, symbols: List[str] = None, params={}) -> Tickers:
        """
        :see: https://docs.valr.com/#cd1f0448-3da3-44cf-b00d-91edd74e7e19
        fetch market statistics for the multiple markets on the exchange
        :param str [symbol]: unified symbol of the market the order was made in
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a assiative array of `Ticker Structure <https://docs.ccxt.com/#/?id=ticker-structure>`
        """
        self.load_markets()
        response = self.publicGetMarketsummary(params)
        # [
        #     {
        #       "currencyPair": "BTCZAR",
        #       "askPrice": "520000",
        #       "bidPrice": "400000",
        #       "lastTradedPrice": "400000",
        #       "previousClosePrice": "400000",
        #       "baseVolume": "0",
        #       "highPrice": "400000",
        #       "lowPrice": "0",
        #       "created": "2022-06-12T18:06:05.001Z",
        #       "changeFromPrevious": "0",
        #       "markPrice": "400000"
        #     },
        #     {
        #       "currencyPair": "ETHZAR",
        #       "askPrice": "32158",
        #       "bidPrice": "30899",
        #       "lastTradedPrice": "30899",
        #       "previousClosePrice": "30899",
        #       "baseVolume": "0",
        #       "highPrice": "30899",
        #       "lowPrice": "0",
        #       "created": "2022-06-12T18:06:05.001Z",
        #       "changeFromPrevious": "0",
        #       "markPrice": "30899"
        #     },
        #     ...
        # ]
        return self.parse_tickers(response, symbols, params)

    def fetch_ticker(self, symbol: str, params={}) -> Ticker:
        """
        :see: https://docs.valr.com/#89b446bb-60a6-42ff-aa09-29e4918a9eb0
        fetch market statistics for a market on the exchange
        :param str symbol: unified symbol of the market the order was made in
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a `Ticker Structure <https://docs.ccxt.com/#/?id=ticker-structure>`
        """
        self.load_markets()
        self.check_required_symbol_argument(self.id + ' fetchTicker', symbol)
        marketId = self.market_id(symbol)
        request = {
            'pair': marketId,
        }
        response = self.publicGetPairMarketsummary(self.extend(request, params))
        return self.parse_ticker(response)

    def parse_ticker(self, ticker: object, market: Market = None) -> Ticker:
        timestamp = self.parse8601(self.safe_string(ticker, 'created'))
        result = {
            'symbol': self.safe_symbol(self.safe_string_2(ticker, 'currencyPair', 'currencyPairSymbol')),
            'info': ticker,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'high': self.safe_string(ticker, 'highPrice'),
            'low': self.safe_string(ticker, 'lowPrice'),
            'bid': self.safe_string(ticker, 'bidPrice'),
            'ask': self.safe_string(ticker, 'askPrice'),
            'close': self.safe_string(ticker, ''),
            'last': self.safe_string(ticker, 'lastTradedPrice'),
            'open': self.safe_string(ticker, 'previousClosePrice'),
            'previousClose': self.safe_string(ticker, 'previousClosePrice'),
            'average': self.safe_string(ticker, 'markPrice'),
            'change': None,
            'percentage': self.safe_string(ticker, 'changeFromPrevious'),
            'baseVolume': self.safe_string(ticker, 'baseVolume'),
            'quoteVolume': self.safe_string(ticker, 'quoteVolume'),
        }
        return self.safe_ticker(result)

    def fetch_order_book(self, symbol: str, limit: Int = None, params={}) -> OrderBook:
        """
        :see: https://docs.valr.com/#89b446bb-60a6-42ff-aa09-29e4918a9eb0
        fetches upto a maximum of the top 40 bids and asks in the order book
        :param str symbol: unified symbol of the market the order was made in
        :param Int [limit]: the maximum number of order book structures to retrieve
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a `Order Book Structure <https://docs.ccxt.com/#/?id=order-book-structure>`
        """
        self.load_markets()
        response = None
        self.check_required_symbol_argument('fetchOrderBook', symbol)
        params['pair'] = self.market_id(symbol)
        if self.check_required_credentials(False):
            response = self.privateGetMarketdataPairOrderbook(params)
        else:
            response = self.publicGetPairOrderbook(params)
        lastDateChange = self.safe_string(response, 'LastChange')
        timestamp = self.parse8601(lastDateChange)
        return self.parse_order_book(response, symbol, timestamp, 'Bids', 'Asks', 'price', 'quantity', 'orderCount')

    def fetch_l3_order_book(self, symbol: str, limit: Int = None, params={}) -> OrderBook:
        """
        :see: https://docs.valr.com/#c2acf6b9-dbba-4e6a-9075-a7907360812d
        fetches all bids and asks in the order book
        :param str symbol: unified symbol of the market the order was made in
        :param Int [limit]: the maximum number of order book structures to retrieve
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a `Order Book Structure <https://docs.ccxt.com/#/?id=order-book-structure>`
        """
        self.load_markets()
        response = None
        self.check_required_symbol_argument('fetchOrderBook', symbol)
        params['pair'] = self.market_id(symbol)
        if self.check_required_credentials(False):
            response = self.privateGetMarketdataPairOrderbookFull(params)
        else:
            response = self.publicGetPairOrderbookFull(params)
        lastDateChange = self.safe_string(response, 'LastChange')
        timestamp = self.parse8601(lastDateChange)
        return self.parse_order_book(response, symbol, timestamp, 'Bids', 'Asks', 'price', 'quantity', 'id')

    def fetch_permissions(self, params={}):
        """
        :see: https://docs.valr.com/#af083ac6-0514-4979-9bab-f599ea1bed4f
        returns the current API Key's information and permissions.
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns: an associative array with API enable permissions
        """
        self.check_required_credentials()
        response = self.privateGetAccountApiKeysCurrent(params)
        permissions = self.safe_value(response, 'permissions')
        return {
            'info': response,
            'created': self.parse8601(self.safe_string(response, 'addedAt')),
            'viewaccess': self.in_array('View access', permissions),
            'trade': self.in_array('Trade', permissions),
            'cryptwithdraws': self.in_array('Withdraw', permissions),
            'fiatwithdraws': self.in_array('Link bank account', permissions),
            'transfers': self.in_array('Internal Transfer', permissions),
        }

    def fetch_balance(self, params={}) -> Balances:
        """
        :see: https://docs.valr.com/#60455ec7-ecdc-42ad-9a57-64941299da52
        fetches the the balances in all currencies on the user account.
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a associative array of `balance structure <https://docs.ccxt.com/#/?id=balance-structure>`
        """
        self.load_markets()
        response = self.privateGetAccountBalances(params)
        # [
        #     {
        #       "currency": "USDT",
        #       "available": "44822.97549155",
        #       "reserved": "99.99925",
        #       "total": "145612.43129945",
        #       "updatedAt": "2023-04-25T09:00:04.406Z",
        #       "lendReserved": "100000",
        #       "borrowReserved": "689.4565579",
        #       "borrowedAmount": "0",
        #       "totalInReference": "7828.62533868",
        #       "totalInReferenceWeighted": "7828.62533868",
        #       "referenceCurrency": "USDC"
        #     },
        #     {
        #       "currency": "BTC",
        #       "available": "0",
        #       "reserved": "0",
        #       "total": "-0.00101056",
        #       "updatedAt": "2023-04-25T09:00:00.103Z",
        #       "lendReserved": "0",
        #       "borrowReserved": "0",
        #       "borrowedAmount": "0.00101056",
        #       "totalInReference": "-28.29568",
        #       "totalInReferenceWeighted": "-27.588288",
        #       "referenceCurrency": "USDC"
        #     }
        # ]
        return self.parse_balance(response)

    def parse_balance(self, balances) -> Balances:
        result = {
            'timestamp': None,
            'datetime': None,
            'info': balances,
        }
        for i in range(0, len(balances)):
            balance = balances[i]
            code = self.safe_currency_code(self.safe_string(balance, 'currency'))
            debt = Precise.string_add(
                self.safe_string(balance, 'lendReserved'),
                self.safe_string(balance, 'borrowReserved')
            )
            result[code] = {
                'free': self.safe_float(balance, 'available'),
                'used': self.safe_float(balance, 'reserved'),
                'total': self.safe_float(balance, 'total'),
                'debt': debt,
            }
        return self.safe_balance(result)

    def fetch_accounts(self, params={}) -> List[Account]:
        """
        :see: https://docs.valr.com/#9443d7ce-c1c5-4597-b43e-d8fc2e7b49a7
        fetch all the accounts associated with a profile
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a dictionary of `account structures <https://docs.ccxt.com/#/?id=account-structure>` indexed by the account type
        """
        response = self.privateGetAccountSubaccounts(params)
        return self.parse_accounts(response, params)

    def parse_account(self, account):
        accountType = None
        if self.safe_string(account, 'label') == 'Primary':
            accountType = 'main'
        else:
            accountType = 'subaccount'
        # Todo: Use account structure
        return {
            'id': self.safe_string(account, 'id'),
            'type': accountType,
            'name': self.safe_string(account, 'label'),
            'code': None,
            'info': account,
        }

    def fetch_order(self, id: str, symbol: str = None, params={}) -> Order:
        """
        :see: https://docs.valr.com/#8d9252e1-ee27-495e-86ed-57458bdafd19
        fetches information on an order made by the user
        :param str id: order id
        :param str symbol: unified symbol of the market the order was made in
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: An `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        self.load_markets()
        self.check_required_symbol_argument('fetchOrder', symbol)
        marketId = self.market_id(symbol)
        request = {
            'id': id,
            'pair': marketId,
        }
        response = self.privateGetOrdersPairOrderidId(self.extend(request, params))
        # {
        #     "orderId": "00fa7cb4-ea7c-4b8e-beed-dc63e226a6a2",
        #     "orderStatusType": "Placed",
        #     "currencyPair": "BTCZAR",
        #     "originalPrice": "100000",
        #     "remainingQuantity": "0.02",
        #     "originalQuantity": "0.02",
        #     "orderSide": "buy",
        #     "orderType": "post-only limit",
        #     "failedReason": "",
        #     "orderUpdatedAt": "2024-03-12T09:42:37.766Z",
        #     "orderCreatedAt": "2024-03-12T09:42:37.766Z",
        #     "timeInForce": "GTC"
        # }
        return self.parse_order(response)

    def fetch_open_orders(self, symbol: str = None, since: Int = None, limit: Int = None, params={}) -> List[Order]:
        """
        fetches information on all order made by the user
        :see: https://docs.valr.com/#910bc498-b88d-48e8-b392-6cc94b8cb66d
        :param str [symbol]: unified symbol of the market the order was made in
        :param int [since]: the earliest time in ms to fetch orders for
        :param int [limit]: the maximum number of order structures to retrieve
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a list of `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        self.load_markets()
        response = self.privateGetOrdersOpen(params)
        # [{'orderId': 'aa6dce9a-6acb-477f-9da8-223127e6b32d',
        # 'side': 'buy',
        # 'remainingQuantity': '0.02',
        # 'price': '100000',
        # 'currencyPair': 'BTCZAR',
        # 'createdAt': '2024-03-12T07:14:17.275Z',
        # 'originalQuantity': '0.02',
        # 'filledPercentage': '0.00',
        # 'updatedAt': '2024-03-12T07:14:17.275Z',
        # 'status': 'Placed',
        # 'type': 'post-only limit',
        # 'timeInForce': 'GTC'}]
        market = None
        if symbol is not None:
            market = self.safe_value(self.markets, symbol)
        return self.parse_orders(response, market, since, limit, params)

    def fetch_closed_orders(self, symbol: str = None, since: Int = None, limit: Int = None, params={}) -> List[Order]:
        """
        fetches information on all closed order made by the user
        :see: https://docs.valr.com/#0d7cc0ff-b8ca-4e1f-980e-36d07672e53d
        :param str [symbol]: unified symbol of the market the order was made in
        :param int [since]: the earliest time in ms to fetch orders for
        :param int [limit]: the maximum number of order structures to retrieve
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a list of `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        self.load_markets()
        response = self.privateGetOrdersHistory(params)
        # [{'orderId': 'aa6dce9a-6acb-477f-9da8-223127e6b32d',
        #   'orderStatusType': 'Cancelled',
        #   'currencyPair': 'BTCZAR',
        #   'averagePrice': '0',
        #   'originalPrice': '100000',
        #   'remainingQuantity': '0.02',
        #   'originalQuantity': '0.02',
        #   'total': '0',
        #   'totalFee': '0',
        #   'feeCurrency': 'BTC',
        #   'orderSide': 'buy',
        #   'orderType': 'post-only limit',
        #   'failedReason': '',
        #   'orderUpdatedAt': '2024-03-12T07:16:14.205Z',
        #   'orderCreatedAt': '2024-03-12T07:14:17.275Z',
        #   'timeInForce': 'GTC'}]
        market = None
        if symbol is not None:
            market = self.safe_value(self.markets, symbol)
        return self.parse_orders(response, market, since, limit, params)

    def parse_order(self, order, market: Market = None) -> Order:
        orderStatus = self.safe_string(order, 'status')
        status = None
        if orderStatus == 'Placed' or orderStatus == 'Active':
            status = 'open'
        elif orderStatus == 'Failed':
            status = 'canceled'
        elif orderStatus == 'Filled':
            status = 'closed'
        orderType = self.safe_string_2(order, 'type', 'orderType')
        type = None
        if orderType is not None:
            if orderType == 'market':
                type = 'market'
            elif orderType.find('limit'):
                type = 'limit'
        datetime = self.safe_string_2(order, 'createdAt', 'orderCreatedAt')
        updateDatetime = self.safe_string_2(order, 'updatedAt', 'orderUpdatedAt')
        result = {
            'id': self.safe_string(order, 'orderId'),
            'clientOrderId': self.safe_string(order, 'customerOrderId'),
            'timestamp': self.parse8601(datetime),
            'datetime': datetime,
            'symbol': self.safe_symbol(self.safe_string(order, 'currencyPair')),
            'type': type,
            'side': self.safe_string(order, 'side'),
            'lastTradeTimestamp': None,
            'lastUpdateTimestamp': self.parse8601(updateDatetime),
            'price': self.safe_string(order, 'price'),
            'amount': self.safe_string(order, 'originalQuantity'),
            'cost': None,
            'average': self.safe_string(order, 'averagePrice'),
            'filled': None,
            'remaining': self.safe_string(order, 'remainingQuantity'),
            'timeInForce': self.safe_string(order, 'timeInForce'),
            'postOnly': None,
            'trades': None,
            'reduceOnly': self.safe_value(order, 'reduceOnly'),
            'triggerPrice': None,
            'takeProfitPrice': None,
            'stopLossPrice': None,
            'status': status,
            'fee': None,
            'info': order,
        }
        return self.safe_order(result, market)

    def create_order(self, symbol: str, type: OrderType, side: OrderSide, amount: float, price: float = None, params={}) -> Order:
        """
        :see: https://docs.valr.com/#5beb7328-24ca-4d8a-84f2-6029725ad923
        Create a trade order
        :param str symbol: unified symbol of the market to create an order in
        :param str type: 'market' or 'limit'
        :param str side: 'buy' or 'sell'
        :param float amount: how much of currency you want to trade in units of base currency
        :param float [price]: the price at which the order is to be fullfilled, in units of the quote currency. If included in market order, use quote amount
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param dict [params.postOnly]: if True will place a limit order and fail if matched immidiately
        :param dict [params.customerOrderId]: an optional field which can be specified by clients to track self order using their own internal order management systems
        :param dict [params.allowMargin]: Set to True for a margin / leverage trade
        :returns dict: an `order structure <https://docs.ccxt.com/#/?id=order-structure>` with only the id and symbol added
        """
        self.load_markets()
        response = None
        self.check_required_symbol_argument('createOrder', symbol)
        marketId = self.market_id(symbol)
        if side != 'buy' and side != 'sell':
            raise InvalidOrder(self.id + ' createOrder() - "side" must be either "buy" or "sell".')
        body = {
            'side': side.upper(),
            'pair': marketId,
        }
        # Optional parameters
        if self.safe_string(params, 'customerOrderId'):
            body['customerOrderId'] = self.safe_string(params, 'customerOrderId')
        if self.safe_string(params, 'allowMargin'):
            body['allowMargin'] = self.safe_string(params, 'allowMargin')
        self.omit(params, ['allowMargin', 'customerOrderId'])
        if type == 'market':
            if price:
                body['quoteAmount'] = amount
            else:
                body['baseAmount'] = amount
            self.omit(params, ['baseAmount', 'quoteAmount'])
            response = self.privatePostOrdersMarket(self.extend(body, params))
        elif type == 'limit':
            body['price'] = self.number_to_string(price)
            body['quantity'] = self.number_to_string(amount)
            if self.safe_string(params, 'postOnly'):
                body['postOnly'] = self.safe_bool(params, 'postOnly')
                self.omit(params, 'postOnly')
            response = self.privatePostOrdersLimit(self.extend(body, params))
        else:
            raise InvalidOrder(self.id + ' createOrder() - "type" must be either "market" or "limit" to create an order.')
        return self.parse_order({'orderId': self.safe_string(response, 'id'), 'currencyPair': marketId})

    def create_orders(self, orders: List[OrderRequest], params={}) -> List[Order]:
        self.load_markets()
        raise NotSupported(self.id + ' createOrders() is not supported yet')
        # response = self.privatePostBatchOrders()

    def edit_order(self, id: str, symbol: str, type: OrderType, side: OrderSide, amount: float = None, price: float = None, params={}) -> Order:
        self.load_markets()
        self.cancel_order(id, symbol)
        return self.create_order(symbol, type, side, amount, price, params)
        # TODO: Method currently in Beta
        # self.privatePutOrdersModify(self.entend(body, params))

    def cancel_order(self, id: str, symbol: str = None, params={}) -> Order:
        """
        :see: https://docs.valr.com/#3d9ba169-7222-4c0f-ab08-87c22162c0c4
        cancels an open order
        :param str id: order id
        :param str symbol: unified symbol of the market the order was made in
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: an `order structure <https://docs.ccxt.com/#/?id=order-structure>` with only the id and symbol added
        """
        self.load_markets()
        self.check_required_symbol_argument('cancelOrder', symbol)
        marketId = self.market_id(symbol)
        orderFormat = {
            'orderId': id,
            'pair': marketId,
        }
        self.privateDeleteOrdersOrder(self.extend(orderFormat, params))
        return self.parse_order({'id': id, 'currencyPair': marketId})

    def cancel_all_orders(self, symbol: str = None, params={}) -> List[Order]:
        """
        :see: https://docs.valr.com/#90822956-7e25-48a8-bd14-a83fb8766b46
        cancels all an open order or all open orders on a specific market
        :param str [symbol]: unified symbol of the market the order was made in
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: an list of `order structure <https://docs.ccxt.com/#/?id=order-structure>` with only the id and option symbol added
        """
        self.load_markets()
        response = None
        if symbol is None:
            response = self.privateDeleteOrders(params)
        else:
            self.check_required_symbol_argument('cancelAllOrders', symbol)
            marketId = self.market_id(symbol)
            body = {
                'pair': marketId,
            }
            response = self.privateDeleteOrdersPair(self.extend(body, params))
            for i in range(0, len(response)):
                response[i]['currencyPair'] = marketId
        return self.parse_orders(response)

    def fetch_trades(self, symbol: str, since: Int = None, limit: Int = None, params={}) -> List[Trade]:
        """
        :see: https://docs.valr.com/#68ecbf66-c8ab-4460-a1f3-5b245b15877e
        :see: https://docs.valr.com/#8e9429c0-f43b-4483-a2be-d03cd1bbb230
        get the list of most recent trades for a particular symbol. If API keys present, use private API call for improved rate limits
        :param str symbol: unified symbol of the market to fetch trades for
        :param int [since]: timestamp in ms of the earliest trade to fetch
        :param int [limit]: the maximum amount of trades to fetch
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns Trade[]: a list of `trade structures <https://docs.ccxt.com/#/?id=trade-structure>`
        """
        self.load_markets()
        response = None
        self.check_required_symbol_argument('fetchTrades', symbol)
        params['pair'] = self.market_id(symbol)
        if self.check_required_credentials(False):
            response = self.privateGetMarketdataPairTradehistory(params)
            # [
            #     {
            #       "price": "43023",
            #       "quantity": "0.01971316",
            #       "currencyPair": "BTCUSDC",
            #       "tradedAt": "2024-02-07T12:48:40.256Z",
            #       "takerSide": "sell",
            #       "sequenceId": 1204770707632816000,
            #       "id": "37e5fba7-c5b7-11ee-b1a8-c700095e5df0",
            #       "quoteVolume": "848.11928268"
            #     },
            #     {
            #       "price": "42909",
            #       "quantity": "0.00005173",
            #       "currencyPair": "BTCUSDC",
            #       "tradedAt": "2024-02-07T12:24:22.818Z",
            #       "takerSide": "buy",
            #       "sequenceId": 1204764594694783000,
            #       "id": "d33297ae-c5b3-11ee-b1a8-c700095e5df0",
            #       "quoteVolume": "2.21968257"
            #     },
            # ]
        else:
            response = self.publicGetPairTrades(params)
            # [
            #     {
            #       "price": "43064",
            #       "quantity": "0.00079928",
            #       "currencyPair": "BTCUSDC",
            #       "tradedAt": "2024-02-05T07:47:04.625Z",
            #       "takerSide": "sell",
            #       "sequenceId": 1203970033324130300,
            #       "id": "c13c5166-c3fa-11ee-b1a8-c700095e5df0",
            #       "quoteVolume": "34.42019392"
            #     },
            #     {
            #       "price": "43010",
            #       "quantity": "0.0001",
            #       "currencyPair": "BTCUSDC",
            #       "tradedAt": "2024-02-05T07:39:40.198Z",
            #       "takerSide": "buy",
            #       "sequenceId": 1203968169262186500,
            #       "id": "b8562435-c3f9-11ee-b1a8-c700095e5df0",
            #       "quoteVolume": "4.301"
            #     },
            # ]
        return self.parse_trades(response, None, since, limit, params)

    def fetch_my_trades(self, symbol: str = None, since: Int = None, limit: Int = None, params={}) -> List[Trade]:
        """
        :see: https://docs.valr.com/#68ecbf66-c8ab-4460-a1f3-5b245b15877e
        :see: https://docs.valr.com/#8e9429c0-f43b-4483-a2be-d03cd1bbb230
        get the list of most recent trades for a particular symbol for the profile.
        :param str symbol: unified symbol of the market to fetch trades for
        :param int [since]: timestamp in ms of the earliest trade to fetch
        :param int [limit]: the maximum amount of trades to fetch
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns Trade[]: a list of `trade structures <https://docs.ccxt.com/#/?id=trade-structure>`
        """
        self.load_markets()
        self.check_required_symbol_argument('fetchMyTrades', symbol)
        params['pair'] = self.market_id(symbol)
        response = self.privateGetAccountPairTradehistory(params)
        # [
        #     {
        #       "price": "29001",
        #       "quantity": "0.00137926",
        #       "currencyPair": "BTCUSDC",
        #       "tradedAt": "2024-02-07T06:00:30.180Z",
        #       "side": "buy",
        #       "sequenceId": 1204667988813283300,
        #       "id": "32ad194e-c57e-11ee-9935-593da58a6690",
        #       "orderId": "3fda280f-e87e-44c8-babf-852da844e514",
        #       "fee": "0.000000413778",
        #       "feeCurrency": "BTC"
        #     },
        #     {'price': '19.3017',
        #     'quantity': '1',
        #     'currencyPair': 'USDCZAR',
        #     'tradedAt': '2024-02-27T14:46:44.852Z',
        #     'side': 'sell',
        #     'sequenceId': '1212048179894161409',
        #     'id': '06e88b34-d57f-11ee-92bb-d59de6d96a53',
        #     'orderId': '5ae9af1e-eb05-427e-af4f-50bcbd9dc8f1',
        #     'makerReward': '0.0001',
        #     'makerRewardCurrency': 'USDC'}
        # ]
        return self.parse_trades(response, None, since, limit, params)

    def parse_trade(self, trade: object, market: Market = None) -> Trade:
        symbol = self.safe_symbol(self.safe_string(trade, 'currencyPair'))
        timestamp = self.parse8601(self.safe_string(trade, 'tradedAt'))
        takerOrMaker = None
        feeCost = self.safe_number_2(trade, 'fee', 'makerReward')
        # tradeType = None
        if 'makerReward' in trade:
            takerOrMaker = 'maker'
            feeCost = -feeCost if (feeCost) else feeCost
        else:
            takerOrMaker = 'taker'
        fee = {
            'currency': self.safe_string_2(trade, 'feeCurrency', 'makerRewardCurrency'),
            'cost': feeCost,
            'rate': None,
        }
        return self.safe_trade({
            'info': trade,
            'timestamp': timestamp,
            'datetime': self.safe_string(trade, 'tradedAt'),
            'id': self.safe_string(trade, 'id'),
            'order': self.safe_string(trade, 'orderId'),
            'symbol': symbol,
            'type': 'market' if (takerOrMaker == 'taker') else 'limit',
            'side': self.safe_string_2(trade, 'side', 'takerSide'),
            'amount': self.safe_number(trade, 'quantity'),
            'price': self.safe_number(trade, 'price'),
            'cost': self.safe_number(trade, 'quoteVolume'),
            'takerOrMaker': takerOrMaker,
            'fee': fee,
        })

    def fetch_trading_fees(self, params={}) -> TradingFees:
        """
        :see: https://docs.valr.com/#00502bc7-bf1e-40d5-b284-25fa719f0229
        fetch the trading fees for multiple markets
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a dictionary of `fee structures <https://docs.ccxt.com/#/?id=fee-structure>` indexed by market symbols
        """
        self.load_markets()
        response = self.privateGetAccountFeesTrade(params)
        if not isinstance(response, list):
            raise NullResponse(self.id + ' ' + 'fetchTradingFees() received incorrect response')
        result = {}
        for i in range(0, len(response)):
            tradeFee = response[i]
            symbol = self.safe_symbol(self.safe_string(tradeFee, 'currencyPair'))
            if ('makerPercentage' in tradeFee) and ('takerPercentage' in tradeFee):
                makerStr = self.safe_string(tradeFee, 'makerPercentage')
                takerStr = self.safe_string(tradeFee, 'takerPercentage')
                makerStr = Precise.string_div(makerStr, '100') if (makerStr) else None
                takerStr = Precise.string_div(takerStr, '100') if (takerStr) else None
                result[symbol] = {
                    'maker': self.parse_number(makerStr),
                    'taker': self.parse_number(takerStr),
                    'info': tradeFee,
                    'symbol': symbol,
                    'percentage': True,
                    'tierBased': False,
                }
            else:
                # Trading pair only avialble on VALR simple buy/sell platform and not trading platform.
                continue
        return result
        # todo: Let fetchTradingFee only returned symbol instead of all - requires update in Exchange.ts
        # todo: Update .market values with feeTrading values.

    def load_trading_fees(self, params={}):
        self.load_markets()
        tradingFees = self.fetch_trading_fees(params)
        tradingFeesList = self.to_array(tradingFees)
        for i in range(0, len(tradingFeesList)):
            tradeFee = tradingFeesList[i]
            symbol = tradeFee['symbol']
            if self.in_array(symbol, self.markets):
                self.markets[symbol]['taker'] = tradeFee['taker']
                self.markets[symbol]['maker'] = tradeFee['maker']

    def fetch_deposit_address(self, code: str, params={}):
        """
        :see: https://docs.valr.com/#b10ea5dd-00cb-4c33-bb28-53104a8f1b7b
        :see: https://docs.valr.com/#619d83fa-f562-4ed3-a573-81afbafd2f1c
        fetch the deposit address for a currency associated with self account
        :param str code: unified currency code
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: an `address structure <https://docs.ccxt.com/#/?id=address-structure>`
        """
        self.load_markets()
        self.check_required_currency_code_argument('fetchDepositAddress', code)
        response = None
        currency = self.safe_currency(code)
        currencyId = {
            'currency': currency['id'],
        }
        if self.is_fiat(code):
            response = self.privateGetWalletFiatCurrencyDepositReference(self.extend(currencyId, params))
            # {'reference': 'USDGVVU6XR'}
        else:
            response = self.privateGetWalletCryptoCurrencyDepositAddress(self.extend(currencyId, params))
            # {'currency': 'BTC',
            # 'address': '3Af2LnWaUFS2wXmXQMugsEtnq7iJTEncfX',
            # 'networkType': 'Bitcoin'}
        return self.parse_deposit_address(response, currency)

    def parse_deposit_address(self, depositAddress, currency: Currency = None):
        currencyId = self.safe_string(currency, 'id')
        return {
            'currency': self.safe_currency_code(self.safe_string(depositAddress, 'currency', currencyId)),
            'network': self.safe_string(depositAddress, 'networkType'),
            'address': self.safe_string_2(depositAddress, 'address', 'reference'),
            'tag': self.safe_string(depositAddress, 'paymentReference'),
            'info': depositAddress,
        }

    def fetch_deposits(self, code: str = None, since: Int = None, limit: Int = None, params={}) -> List[Transaction]:
        """
        fetch all deposits made to an account
        :see: https://docs.valr.com/#1061d8de-3792-4a0a-8ae6-715cb8a5179e
        :param str code: unified currency code
        :param int [since]: the earliest time in ms to fetch deposits for
        :param int [limit]: the maximum number of deposits structures to retrieve
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict[]: a list of `transaction structures <https://docs.ccxt.com/#/?id=transaction-structure>`
        """
        self.load_markets()
        self.check_required_currency_code_argument('fetchDeposits', code)
        if self.is_fiat(code):
            raise NotSupported(self.id + ' fetchDeposits() is not supported yet for fiat currencies')
        currency = self.safe_currency(code)
        currencyId = {
            'currency': currency['id'],
        }
        response = self.privateGetWalletCryptoCurrencyDepositHistory(self.extend(currencyId, params))
        # [
        #     {
        #       "currencyCode": "BTC",
        #       "receiveAddress": "2MvLmR6cd4YVDFAU8BTujKkzrV1dwFaNHup",
        #       "transactionHash": "fb588e3be006058c5853880421ef7241388270e2b506ce7ca553f8e5b797f628",
        #       "networkType": "Bitcoin",
        #       "amount": "0.01",
        #       "createdAt": "2019-03-01T14:36:53Z",
        #       "confirmations": 2,
        #       "confirmed": True,
        #       "confirmedAt": "2019-03-01T14:48:47.340347Z"
        #     },
        #     {
        #       "currencyCode": "BTC",
        #       "receiveAddress": "2MvLmR6cd4YVDFAU8BTujKkzrV1dwFaNHup",
        #       "transactionHash": "a0a70db6c1b2f84caa562e8523f0aaee83c73d1e9ff97e9ec2d6b36f4ad56f3e",
        #       "networkType": "Bitcoin",
        #       "amount": "0.11229885",
        #       "createdAt": "2019-01-11T08:54:20Z",
        #       "confirmations": 0,
        #       "confirmed": True,
        #       "confirmedAt": "2019-01-11T09:30:57.265843Z"
        #     }
        #   ]
        return self.parse_transactions(response)
        # Todo - Update Exchange.ts fetchDeposits argument from symbol to code parameter

    def fetch_withdrawals(self, code: str = None, since: Int = None, limit: Int = None, params={}) -> List[Transaction]:
        """
        :see: https://docs.valr.com/#d166dbf5-e922-4037-b0a7-5d490796662c
        fetch history of withdrawals
        :param str [code]: unified currency code for the currency of the deposit/withdrawals, default is None
        :param int [since]: timestamp in ms of the earliest deposit/withdrawal, default is None
        :param int [limit]: max number of deposit/withdrawals to return, default is None
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a list of `transaction structure <https://docs.ccxt.com/#/?id=transaction-structure>`
        """
        self.load_markets()
        self.check_required_currency_code_argument('fetchWithdrawals', code)
        if self.is_fiat(code):
            raise NotSupported(self.id + ' fetchWithdrawals() is not supported yet for fiat currencies')
        currency = {
            'currency': self.safe_currency(code)['id'],
        }
        response = self.privateGetWalletCryptoCurrencyWithdrawHistory(self.extend(currency, params))
        # [
        #     {
        #       "currency": "BTC",
        #       "address": "invalidAddress123",
        #       "amount": "0.0001",
        #       "feeAmount": "0.0002",
        #       "confirmations": 0,
        #       "uniqueId": "2ab9dfce-7818-4812-9b33-fee7bd7c7c5a",
        #       "createdAt": "2019-04-20T14:30:26.950Z",
        #       "verified": True,
        #       "status": "Failed",
        #       "networkType": "Bitcoin"
        #     },
        #     {
        #       "currency": "BTC",
        #       "address": "mkHS9ne12qx9pS9VojpwU5xtRd4T7X7ZUt",
        #       "amount": "0.19974963",
        #       "feeAmount": "0.0002",
        #       "transactionHash": "a79535cc38f515d1c3ecac364057521ffece9ed0ed11667ba2b83bcc8c065994",
        #       "confirmations": 2,
        #       "lastConfirmationAt": "2019-03-12T08:08:13.879189",
        #       "uniqueId": "a243daf8-cc5d-4e61-9618-433e0d4c79ac",
        #       "createdAt": "2019-03-11T10:36:23.739Z",
        #       "verified": True,
        #       "status": "Complete",
        #       "networkType": "Bitcoin"
        #     },
        #     {
        #       "currency": "BTC",
        #       "address": "mkuKgijS7w4hjWL3Zs7kw7HQvM85a2F8RZ",
        #       "amount": "0.01",
        #       "feeAmount": "0.00055",
        #       "transactionHash": "87d8701d3b241cc6a32b10388ad5c6f8cf9a9336d9e9fcd2592ad84b57473eb9",
        #       "confirmations": 2,
        #       "lastConfirmationAt": "2019-01-12T08:55:14.692649",
        #       "uniqueId": "be612be3-06e3-4214-b81e-9bf8e645c28a",
        #       "createdAt": "2019-01-11T12:56:21.080Z",
        #       "verified": True,
        #       "status": "Processing",
        #       "networkType": "Bitcoin"
        #     }
        #   ]
        return self.parse_transactions(response)
        # Todo - Update Exchange.ts fetchDeposits argument from symbol to code parameter

    def withdraw(self, code: str, amount: float, address: str, tag=None, params={}) -> Transaction:
        """
        :see: https://docs.valr.com/#bb0ad4dc-a28d-41a3-8e59-5070bc589c5a
        :see: https://docs.valr.com/#fb4db187-530b-4632-b933-7bdfd192bcf5
        make a withdrawal
        :param str code: unified currency code
        :param float amount: the amount to withdraw
        :param str address: the address to withdraw to
        :param str tag:
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a `transaction structure <https://docs.ccxt.com/#/?id=transaction-structure>`
        """
        self.load_markets()
        self.check_required_currency_code_argument('fetchWithdrawals', code)
        currency = self.safe_currency(code)
        # todo: Include 'networkType' from default currency if none provided via params
        response = None
        if self.is_fiat(code):
            withdrawalBody = {
                'currency': currency['id'],
                'linkedBankAccountId': address,
                'amount': self.number_to_string(amount),
            }
            response = self.privatePostWalletFiatCurrencyWithdraw(self.extend(withdrawalBody, params))
        else:
            withdrawalBody = {
                'currency': currency['id'],
                'address': address,
                'amount': self.number_to_string(amount),
            }
            response = self.privatePostWalletCryptoCurrencyWithdraw(self.extend(withdrawalBody, params))
        return self.parse_transaction(response)

    def parse_transaction(self, transaction, currency: Currency = None) -> Transaction:
        timestamp = self.parse8601(self.safe_string(transaction, 'createdAt'))
        code = self.safe_currency_code(self.safe_string(transaction, 'currencyCode'))
        status = None
        if self.safe_bool(transaction, 'confirmed'):
            status = 'ok'
        transactionType = None
        if 'receiveAddress' in transaction:
            transactionType = 'deposit'
        return {
            'info': transaction,
            'id': self.safe_string(transaction, 'id'),
            'txid': self.safe_string(transaction, 'transactionHash'),
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'address': self.safe_string(transaction, 'receiveAddress'),
            'addressFrom': None,
            'addressTo': None,
            'tag': None,
            'tagFrom': None,
            'tagTo': None,
            'type': transactionType,
            'amount': self.safe_number(transaction, 'amount'),
            'currency': code,
            'status': status,
            'updated': self.parse8601(self.safe_string(transaction, 'confirmedAt')),
            'fee': None,
            'network': self.safe_string(transaction, 'networkType'),
            'comment': None,
            'internal': None,
        }

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        partialPath = self.implode_params(path, params)
        url = self.urls['api'][api] + '/' + partialPath
        query = self.omit(params, self.extract_params(path))
        if query:
            if method == 'POST' or method == 'PUT' or method == 'DELETE':
                body = self.json(query)
            else:
                url += '?' + self.urlencode(query)
        signHeaders = None
        if api == 'private':
            full_path = '/v' + self.version + '/' + partialPath
            self.check_required_credentials()
            timestamp = str(self.milliseconds())
            message = timestamp + method.upper() + full_path
            if body is not None:
                message += body
            payloadBase64 = self.string_to_base64(message)
            signature = self.hmac(
                self.base64_to_binary(payloadBase64),
                self.base64_to_binary(self.string_to_base64(self.secret)),
                'sha512',
                'hex'
            )
            signHeaders = {
                # 'Content-Type': 'application/json',
                'X-VALR-API-KEY': self.apiKey,
                'X-VALR-SIGNATURE': signature,
                'X-VALR-TIMESTAMP': timestamp,
            }
        return {'url': url, 'method': method, 'body': body, 'headers': self.deep_extend(headers, signHeaders)}
